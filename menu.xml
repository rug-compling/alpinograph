<?xml version="1.0" encoding="UTF-8"?>
<menu>

  <item id="idx" lbl="Index">
    <item id="idx-doc" lbl="Corpusinformatie">
      match (d:doc)
      return d
    </item>
    <item id="idx-node" lbl="Attributen van nodes">
      match (f:feature{v: 'node'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    </item>
    <item id="idx-word" lbl="Attributen van woorden">
      match (f:feature{v: 'word'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    </item>
    <item id="idx-rel" lbl="Attributen van relaties">
      match (f:feature{v: 'rel'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    </item>
    <item id="idx-meta" lbl="Soorten metadata">
      match (f:feature{v: 'meta'})
      return f.name as metadata, f.count as aantal
      order by metadata
    </item>
  </item>

  <item id="tut" lbl="Voorbeelden">
    <item id="tut-inl" lbl="Inleiding">
      <item id="tut-inl-node" lbl="Node">
        -- Een vertex in de graaf dat geen woord is
        -- (of een multi-word unit)

        match (n:node)
        return n
        limit 10
      </item>
      <item id="tut-inl-word" lbl="Woord">
        match (w:word)
        return w
        limit 10
      </item>
      <item id="tut-inl-nw" lbl="Node of woord">
        -- :nw is een alias voor :node en :word samen

        match (n:nw)
        return n
        limit 10
      </item>
      <item id="tut-inl-zin" lbl="Zin">
        match (s:sentence)
        return s
        limit 10
      </item>
      <item id="tut-inl-meta" lbl="Metadata">
        match (m:meta)
        return m.sentid as "sentence ID", m.type, m.name, m.value
        limit 10
      </item>
      <item id="tut-inl-corpus" lbl="Corpusinformatie">
        match (d:doc)
        return d
      </item>
      <item id="tut-inl-attr" lbl="Attributen">
        -- Tellingen van verschillende soorten attributen

        match (f:feature)
        return f
        limit 10
      </item>
      <item id="tut-inl-rel" lbl="Relatie">
        match ()-[r]->()
        return r
        limit 10
      </item>
      <item id="tut-inl-roor" lbl="Root">
        -- :sentence fungeert als root voor verschillende soorten relaties

        match (:sentence)-[r]->()
        return r
        limit 10
      </item>
    </item>
    <item id="tut-next" lbl="Woorden en woordgroepen">
      <item id="tut-next-next" lbl="De next-relatie">
        -- De relatie :next verbindt twee opeenvolgende woorden met elkaar

        match p = ()-[:next]->()
        return p
      </item>
      <item id="tut-next-first" lbl="De eerste twee woorden van de zin">
        match p = (:word{begin:0})-[:next]->()
        return p
      </item>
      <item id="tut-next-last" lbl="De laatste twee woorden van de zin">
        match p = ()-[:next]->(:word{last:true})
        return p
      </item>
      <item id="tut-next-woorden" lbl="Woorden in dezelfde zin">
        -- Zoek zinnen met zowel 'dag' als 'jaar'

        match (w1:word{lemma: 'dag'}),
              (w2:word{sentid: w1.sentid, lemma: 'jaar'})
        return w1, w2
      </item>
      <item id="tut-next-near" lbl="Woorden bij elkaar in de buurt">
        -- Zoek zinnen met zowel 'dag' als 'jaar'
        -- Maximaal twee andere woorden tussen 'dag' en 'jaar'
        -- Omdat de link geen richting bevat is de volgorde vrij

        match p = (:word{lemma: 'dag'})-[:next*1..3]-(:word{lemma: 'jaar'})
        return p
      </item>
      <item id="tut-next-groep" lbl="Woordgroepen">
        -- Welke woord volgt het vaakst na 'per'?

        match (:word{lemma: 'per'})-[:next]->(w:word)
        return w.lemma, count(w.lemma) as aantal
        order by aantal desc
      </item>
      <item id="tut-next-mwu" lbl="Multi-word units">
        -- Een multi-word unit is de enige vertex van het type 'node' met de attributen 'word', 'lemma' en 'pt'
        -- De waarde voor 'pt' is altijd 'mwu', net als voor 'cat' in dit geval

        match (w:node{cat: 'mwu'})
        return w.word, count(w.word) as aantal
        order by aantal desc
      </item>
    </item>
    <item id="tut-pair" lbl="Woordpaar-relaties">
      <item id="tut-pair-pair" lbl="De pair-relatie">
        match p = (:word)-[:pair]->(:word)
        return p
      </item>
      <item id="tut-pair-graag" lbl="Wat doen we graag?">
        -- Werkwoorden met 'graag' als modifier

        match p = (:nw{pt: 'ww'})-[:pair{rel: 'mod'}]->(:word{lemma: 'graag'})
        return p
      </item>
      <item id="tut-pair-eten" lbl="Wat wordt er gegeten?">
        -- Zelfstandig naamwoorden als 'obj1' van het werkwoord 'eten' of 'opeten'

        match (w1:word{pt: 'ww'})-[:pair{rel: 'obj1'}]->(w:word{pt: 'n'})
        where w1.lemma in ['eten', 'opeten']
        return w.lemma, count(w.lemma) as aantal
        order by aantal desc
      </item>
      <item id="tut-pair-obj12" lbl="Werkwoorden met lijdend voorwerp en meewerkend voorwerp">
        match (w1:nw)&lt;-[:pair{rel:'obj1'}]-(w:word{pt:'ww'})-[:pair{rel:'obj2'}]->(w2:nw)
        where w1.pt in ['n', 'mwu']
          and w2.pt in ['n', 'mwu']
        return w.lemma as werkwoord, w1.word as "lijdend voorwerp", w2.word as "meewerkend voorwerp"
      </item>
    </item>
    <item id="tut-rel" lbl="Alpino-structuren">
      <item id="tut-rel-rel" lbl="De Alpino-relatie">
        match p = (:node)-[:rel]->(:nw)
        return p
      </item>
      <item id="tut-rel-kind" lbl="Onderwerpen die het lemma 'kind' bevatten">
        match (:node)-[:rel{rel:'su'}]->(n:nw)-[:rel*0..]->(:word{lemma: 'kind'})
        return n
      </item>
      <item id="tut-rel-mwu-van" lbl="Multi-word units die eindigen met 'van'">
        match (n:node{cat:'mwu'})-[:rel{rel:'mwp'}]->(:word{lemma:'van', end:n.end})
        return n
      </item>
      <item id="tut-rel-rela" lbl="Relatieve zinsdelen">
        match p = (:node{cat:'rel'})-[:rel{rel:'body'}]->(:node{cat:'ssub'})
        return p
      </item>
      <item id="tut-rel-pdp" lbl="Node met twee parents">
        -- In Alpino kan een node maar één parent hebben
        -- In AlpinoGraph zijn nodes met een identieke index versmolten, waardoor 
        --   een node meer dan één parent kan hebben

        match m = (n1:node)-[:rel]->()&lt;-[:rel]-(n2:node)
        where n1.id &lt; n2.id    -- voorkomt dubbelen
        return m
      </item>
    </item>
    <item id="tut-ud" lbl="Universal Dependencies">
      <item id="tut-ud-ud" lbl="De standaard UD-relatie">
        match p = (:word)-[:ud]->(:word)
        return p
      </item>
      <item id="tut-ud-eud" lbl="De Enhanced UD-relatie">
        match p = (:word)-[:eud]->(:word)
        return p
      </item>
      <item id="tut-ud-dep" lbl="De dep-relatie">
        -- :dep is een alias voor :ud en :eud samen

        match p = (:word)-[:dep]->(:word)
        return p
      </item>
      <item id="tut-ud-nsubj" lbl="Onderwerp">
        match ()-[:ud{main:'nsubj'}]->(w)
        return w
      </item>
      <item id="tud-ud-wwobj" lbl="Werkwoord met object">
          match (w1:word{upos:'VERB'})-[:ud{main:'obj'}]->(w2:word)
          where w2.upos != 'PRON'
          return w1, w2
      </item>
      <item id="tut-ud-pos" lbl="Possessieven">
        match (w1:word)-[:ud{rel:'nmod:poss'}]->(w2:word)
        return w1, w2
      </item>
      <item id="tut-ud-reeks" lbl="Een advmod van een amod van een subject">
        match p = ()-[:ud{main:'nsubj'}]->()-[:ud{main:'amod'}]->()-[:ud{main:'advmod'}]->()
        return p
      </item>
    </item>
    <item id="tut-mix" lbl="Heterogene relaties">
      <item id="tut-mix-udmwu" lbl="Universal Dependencies en multi-word units (1)">
        -- Universal dependencies zijn altijd tussen woorden
        -- Soms is dat met een woord dat het begin van een multi-word unit is
        --   en wil je de hele multi-word unit weten
        -- Daarvoor kun je UD-relaties [:ud] combineren met Alpino-relaties [:rel]

        match (:word{lemma:'gebruiken'})-[:ud{rel:'obj'}]->(v1:word)&lt;-[:rel*0..1{rel:'mwp'}]-(v)
        where not exists ( (v)&lt;-[:rel{rel:'mwp'}]-() )
        return v.lemma
      </item>
      <item id="tut-mix-udmwu2" lbl="Universal Dependencies en multi-word units (2)">
        -- Hier zoek je expliciet naar Universal Dependencies met een multi-word unit

        match (w:word)-[u:ud]->(:word)&lt;-[:rel]-(n:node{cat:'mwu'})
        where not u.main in ['flat','fixed']
        return w.lemma, u.rel, n.word
      </item>
      <item id="tut-mix-cop" lbl="Nominalisaties van copula-constructies">
        -- Voor de gevorderde taalkundige
        -- Ook hier wordt een UD-relatie gecombineerd met een Alpino-relatie

        match p = (:node{cat:'np'})-[:rel{rel:'hd'}]->(:word)&lt;-[:ud{main:'cop'}]-(:word)
        return p
      </item>
    </item>
  </item>

  <item id="spod" lbl="SPOD">

    <item id="spod-attrib" lbl="Attributen">
      <item id="spod-pos" lbl="pos">
        match (w:word)
        return w.pos as pos, count(w.pos) as aantal
        order by pos
      </item>
      <item id="spod-postag" lbl="postag">
        match (w:word)
        return w.postag as postag, count(w.postag) as aantal
        order by postag
      </item>
      <item id="spod-pt" lbl="pt">
        match (w:word)
        return w.pt as pt, count(w.pt) as aantal
        order by pt
      </item>
    </item>

    <item id="spod-sents" lbl="Hoofdzinnen">
      <item id="spod-smain" lbl="mededelende hoofdzinnen">
        <item id="spod-smain-zin" lbl="zinnen">
          match p = (:node{cat: 'smain'})
          return p
        </item>
        <item id="spod-smain-tel" lbl="telling">
          match (n:node{cat: 'smain'})
          with n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-whq" lbl="vraagzinnen (wh)">
        <item id="spod-whq-zin" lbl="zinnen">
          match p = (:node{cat: 'whq'})
          return p
        </item>
        <item id="spod-whq-tel" lbl="telling">
          match (n:node{cat: 'whq'})
          with n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-janee" lbl="ja/nee vragen">
        <item id="spod-janee-zin" lbl="zinnen">
          match (w:word{word: '?'}) ,
                (n:node{sentid:w.sentid,cat: 'sv1'})&lt;-[r:rel]-()
          optional match (n)-[:rel{rel: 'hd'}]->(n1)
          with w, r, n, n1
          where not r.rel = 'body'
            and n.end &lt; w.end
            and (n1 is null or n1.stype is null or n1.stype = 'ynquestion')
          return n.sentid, n.id
        </item>
        <item id="spod-janee-tel" lbl="telling">
          match (w:word{word: '?'}) ,
                (n:node{sentid:w.sentid,cat: 'sv1'})&lt;-[r:rel]-()
          optional match (n)-[:rel{rel: 'hd'}]->(n1)
          with w, r, n, n1
          where not r.rel = 'body'
            and n.end &lt; w.end
            and (n1 is null or n1.stype is null or n1.stype = 'ynquestion')
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-imp" lbl="imperatieven">
        <item id="spod-imp-zin" lbl="zinnen">
          match (n:node{cat: 'sv1'})
            optional match (n)-[:rel{rel: 'su'}]->(x1)
            optional match (n)-[:rel{rel: 'hd'}]->(x2)
          with n, x1, x2
          where x1 is null
            and not (x2.stype        is not null and not x2.stype = 'imparative')
            and not ((x2.tense        is not null and x2.tense = 'past') or
                     (x2.pvagr        is not null and x2.pvagr in ['mv','met-t']) or
                     (x2.pvtijd is not null and x2.pvtijd = 'verl') or
                     (x2.lemma        is not null and x2.lemma in ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben']) )
          return n.sentid, n.id
        </item>
        <item id="spod-imp-tel" lbl="telling">
          match (n:node{cat: 'sv1'})
            optional match (n)-[:rel{rel: 'su'}]->(x1)
            optional match (n)-[:rel{rel: 'hd'}]->(x2)
          with n, x1, x2
          where x1 is null
            and not (x2.stype          is not null and not x2.stype = 'imparative')
            and not ((x2.tense  is not null and x2.tense = 'past') or
                     (x2.pvagr  is not null and x2.pvagr in ['mv','met-t']) or
                     (x2.pvtijd is not null and x2.pvtijd = 'verl') or
                     (x2.lemma  is not null and x2.lemma in ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben']) )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
    </item>

    <item id="spod-bijzinnen" lbl="Bijzinnen">
      <item id="spod-whsub" lbl="ingebedde vraagzinnen">
        <item id="spod-whsub-zin" lbl="zinnen">
          match (n:node{cat: 'whsub'})-[:rel*1..2]->(n2:node{cat: 'ssub'})
          where exists ((n)-[:rel{rel: 'body'}]->(n2))
             or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->(n2))
             or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'du'})-[:rel]->(n2))
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-whsub-tel" lbl="telling">
          match (n:node{cat: 'whsub'})-[:rel*1..2]->(n2:node{cat: 'ssub'})
          where exists ((n)-[:rel{rel: 'body'}]->(n2))
             or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->(n2))
             or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'du'})-[:rel]->(n2))
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ssub" lbl="finiete bijzinnen">
        <item id="spod-ssub-zin" lbl="zinnen">
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-ssub-tel" lbl="telling">
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ssubdat" lbl="finiete bijzinnen met &quot;dat&quot;">
        <item id="spod-ssubdat-zin" lbl="zinnen">
          match (n1:word{lemma: 'dat'})&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, n1.id, n2.id
        </item>
        <item id="spod-ssubdat-tel" lbl="telling">
          match (:word{lemma: 'dat'})&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ssubof" lbl="finiete bijzinnen met &quot;of&quot;">
        <item id="spod-ssubof-zin" lbl="zinnen">
          match (w:word{lemma: 'of'})&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, w.id, n2.id
        </item>
        <item id="spod-ssubof-tel" lbl="telling">
          match (:word{lemma: 'of'})&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ssubcmp" lbl="finiete bijzinnen met andere voegwoorden">
        <item id="spod-ssubcmp-zin" lbl="zinnen">
          match (w:nw)&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          where not (w.lemma is not null and w.lemma in ['of','dat'])
          return n.sentid, n.id, w.id, n2.id
        </item>
        <item id="spod-ssubcmp-tel" lbl="telling">
          match (w:nw)&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          where not (w.lemma is not null and w.lemma in ['of','dat'])
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-oti" lbl="infiniete bijzinnen met &quot;om&quot;">
        <item id="spod-oti-zin" lbl="zinnen">
          match p = (:node{cat: 'oti'})
          return p
        </item>
        <item id="spod-oti-tel" lbl="telling">
          match (n:node{cat: 'oti'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-otivc" lbl="infiniete bijzinnen met &quot;om&quot; die als complement optreden">
        <item id="spod-otivc-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'vc'}]-(n2:node)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otivc-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'vc'}]-(:node)
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-otimod" lbl="infiniete bijzinnen met &quot;om&quot; die als bepaling optreden">
        <item id="spod-otimod-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'mod'}]-(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otimod-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'mod'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-otiww" lbl="infiniete bijzinnen met &quot;om&quot; die als bepaling bij een werkwoord optreden">
        <item id="spod-otiww-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-otiww-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(:word{pt: 'ww'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-otin" lbl="infiniete bijzinnen met &quot;om&quot; die als bepaling bij een zelfstandig naamwoord optreden">
        <item id="spod-otin-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word)
          where w.pt in ['n','vnw']
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-otin-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word)
          where w.pt in ['n','vnw']
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-otisu" lbl="infiniete bijzinnen met &quot;om&quot; die als onderwerp fungeren">
        <item id="spod-otisu-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'su'}]-(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otisu-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'su'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-otipred" lbl="infiniete bijzinnen met &quot;om&quot; die als predicaat fungeren">
        <item id="spod-otipred-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'predc'}]-(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otipred-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'predc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-otiobc" lbl="infiniete bijzinnen met &quot;om&quot; die optreden met combinaties zoals &quot;te ADJ; zo ADJ; genoeg ADJ; voldoende N&quot;">
        <item id="spod-otiobc-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'obcomp'}]-(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otiobc-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'obcomp'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-tite" lbl="infiniete bijzinnen met alleen &quot;te&quot;">
        <item id="spod-tite-zin" lbl="zinnen">
          match (n:node{cat: 'ti'})&lt;-[:rel]-(n2:node)
          where not n2.cat in ['oti','cp']
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-tite-tel" lbl="telling">
          match (n:node{cat: 'ti'})&lt;-[:rel]-(n2:node)
          where not n2.cat in ['oti','cp']
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ti" lbl="infiniete bijzinnen met ander voorzetsel">
        <item id="spod-ti-zin" lbl="zinnen">
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ti'})
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-ti-tel" lbl="telling">
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ti'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-relssub" lbl="relatieve bijzinnen">
        <item id="spod-relssub-zin" lbl="zinnen">
          match (n:node{cat: 'rel'})-[:rel{rel: 'body'}]->(n1:node)-[r:rel*0..1]->(n2:node{cat: 'ssub'})
          where length(r) = 0
             or n1.cat = 'conj' and r[0].rel = 'cnj'
             or n1.cat = 'du'
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-relssub-tel" lbl="telling">
          match (n:node{cat: 'rel'})-[:rel{rel: 'body'}]->(n1:node)-[r:rel*0..1]->(n2:node{cat: 'ssub'})
          where length(r) = 0
             or n1.cat = 'conj' and r[0].rel = 'cnj'
             or n1.cat = 'du'
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-whrel" lbl="free relatives">
        <item id="spod-whrel-zin" lbl="zinnen">
          match (n:node{cat: 'whrel'})-[:rel{rel: 'body'}]->(n2:node)
          where n2.cat = 'ssub'
             or n2.cat = 'conj' and exists( (n2)-[:rel{rel: 'cnj'}]->(:node{cat: 'ssub'}) )
             or n2.cat = 'du' and exists( (n2)-[:rel]->(:node{cat: 'ssub'}) )
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-whrel-tel" lbl="telling">
          match (n:node{cat: 'whrel'})-[:rel{rel: 'body'}]->(n2:node)
          where n2.cat = 'ssub'
             or n2.cat = 'conj' and exists( (n2)-[:rel{rel: 'cnj'}]->(:node{cat: 'ssub'}) )
             or n2.cat = 'du' and exists( (n2)-[:rel]->(:node{cat: 'ssub'}) )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
    </item>

    <item id="spod-corc" lbl="Correlatieve comparatieven">
      <item id="spod-corc-zin" lbl="zinnen">
        match p1 = (n1:node{_deste: true})&lt;-[:rel*0..]-(n0:node)&lt;-[:rel*0..]-(n:node{cat: 'du'})
        match p2 = (n1)&lt;-[:rel*0..]-(n0)-[:rel*0..]->(n2:node{_deste: true})
        optional match p = (n0)&lt;-[:rel*0..]-(:node{cat:'du'})&lt;-[:rel*1..]-(n)
        with n1, n2, p, p1, p2
        where n1.id &lt; n2.id
          and p is null
        return p1, p2
      </item>
      <item id="spod-corc-tel" lbl="telling">
        match (n1:node{_deste: true})&lt;-[:rel*0..]-(n0:node)&lt;-[:rel*0..]-(n:node{cat: 'du'})
        match (n1)&lt;-[:rel*0..]-(n0)-[:rel*0..]->(n2:node{_deste: true})
        optional match p = (n0)&lt;-[:rel*0..]-(:node{cat:'du'})&lt;-[:rel*1..]-(n)
        with n, n1, n2, p
        where n1.id &lt; n2.id
          and p is null
        with distinct n.sentid as sentid, n.id as id
        return count(distinct(sentid)) as zinnen, count(sentid) as items
      </item>
    </item>

    <item id="spod-compcomp" lbl="Woorden met een comparatief complement">
      <item id="spod-cc" lbl="totaal">
        <item id="spod-cc-zin" lbl="zinnen">
          match (n:nw)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-cc-tel" lbl="telling">
          match (n:nw)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cczo" lbl="met als hoofd &quot;zo&quot;">
        <item id="spod-cczo-zin" lbl="zinnen">
          match (w:word{lemma: 'zo'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-cczo-tel" lbl="telling">
          match (w:word{lemma: 'zo'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cceven" lbl="met als hoofd &quot;even&quot;">
        <item id="spod-cceven-zin" lbl="zinnen">
          match (w:word{lemma: 'even'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return distinct w.sentid, w.id, n2.id
        </item>
        <item id="spod-cceven-tel" lbl="telling">
          match (w:word{lemma: 'even'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccca" lbl="met als hoofd comparatief adjectief">
        <item id="spod-ccca-zin" lbl="zinnen">
          match (n:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-ccca-tel" lbl="telling">
          match (n:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccdannp" lbl="met als hoofd comparatief adjectief, gevolgd door NP">
        <item id="spod-ccdannp-zin" lbl="zinnen">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)-[:rel{rel: 'body'}]->(x{_np:true})
          return w.sentid, w.id, n2.id, x.id
        </item>
        <item id="spod-ccdannp-tel" lbl="telling">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x{_np:true})
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccdanvs" lbl="met als hoofd comparatief adjectief, gevolgd door VP of S">
        <item id="spod-ccdanvs-zin" lbl="zinnen">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-(n2)-[:rel{rel: 'obcomp'}]->()-[:rel]->(x:nw)
          where (x.cat is not null and x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'])
             or (x.pt is not null and x.pt = 'ww')
          return distinct w.sentid, w.id, n2.id, x.id
        </item>
        <item id="spod-ccdanvs-tel" lbl="telling">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel]->(x:nw)
          where (x.cat is not null and x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'])
             or (x.pt is not null and x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccdanpp" lbl="met als hoofd comparatief adjectief, gevolgd door PP">
        <item id="spod-ccdanpp-zin" lbl="zinnen">
          match (w:word{pt: 'adj',graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-(:node)-[:rel{rel: 'obcomp'}]->(:node)-[:rel{rel: 'body'}]->(n2:node{cat: 'pp'})
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccdanpp-tel" lbl="telling">
          match (w:word{pt: 'adj',graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-(:node)-[:rel{rel: 'obcomp'}]->(:node)-[:rel{rel: 'body'}]->(:node{cat: 'pp'})
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccdanav" lbl="met als hoofd comparatief adjectief, gevolgd door A of ADV">
        <item id="spod-ccdanav-zin" lbl="zinnen">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where (x.cat is not null and x.cat in ['advp','ap'])
             or (x.pt is not null and x.pt in ['adj','bw'])
          return w.sentid, w.id, x.id
        </item>
        <item id="spod-ccdanav-tel" lbl="telling">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where (x.cat is not null and x.cat in ['advp','ap'])
             or (x.pt is not null and x.pt in ['adj','bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccmm" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;">
        <item id="spod-ccmm-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          where w.lemma in ['veel','minder','weinig']
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccmm-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          where w.lemma in ['veel','minder','weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccmdnp" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;, gevolgd door NP">
        <item id="spod-ccmdnp-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw{_np: true})
          where w.lemma in ['veel', 'minder', 'weinig']
          return w.sentid, w.id, x.id
        </item>
        <item id="spod-ccmdnp-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(:nw{_np: true})
          where w.lemma in ['veel', 'minder', 'weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccmdvs" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;, gevolgd door VP of S">
        <item id="spod-ccmdvs-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
            and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          return w.sentid, w.id, x.id
        </item>
        <item id="spod-ccmdvs-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
            and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccmdpp" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;, gevolgd door PP">
        <item id="spod-ccmdpp-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(n2:node{cat: 'pp'})
          where w.lemma in ['veel', 'minder', 'weinig']
          return distinct w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccmdpp-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(:node{cat: 'pp'})
          where w.lemma in ['veel', 'minder', 'weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccmdav" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;, gevolgd door A of ADV">
        <item id="spod-ccmdav-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
            and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          return distinct w.sentid, w.id, x.id
        </item>
        <item id="spod-ccmdav-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
          and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccnn" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;">
        <item id="spod-ccnn-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccnn-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccndnp" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;, gevolgd door NP">
        <item id="spod-ccndnp-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(n2:nw{_np: true})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccndnp-tel" lbl="telling">
            match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(:nw{_np: true})
            where w.lemma in ['niet', 'niets', 'ander', 'anders']
            with distinct w.sentid as sentid, w.id as id
            return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccndvs" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;, gevolgd door VP of S">
        <item id="spod-ccndvs-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
            and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          return distinct w.sentid, w.id, x.id
        </item>
        <item id="spod-ccndvs-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
            and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccndpp" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;, gevolgd door PP">
        <item id="spod-ccndpp-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(n2:node{cat: 'pp'})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccndpp-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(:node{cat: 'pp'})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ccndav" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;, gevolgd door A of ADV">
        <item id="spod-ccndav-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
            and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          return w.sentid, w.id, x.id
        </item>
        <item id="spod-ccndav-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
            and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
    </item>

    <item id="spod-neven" lbl="Nevenschikkingen">
      <item id="spod-conj" lbl="alle nevenschikkingen">
        <item id="spod-conj-zin" lbl="zinnen">
          match p = (:node{cat: 'conj'})
          return p
        </item>
        <item id="spod-conj-tel" lbl="telling">
          match (n:node{cat: 'conj'})
          return count(distinct(n.sentid)) as zinnen, count(n.sentid) as items
        </item>
      </item>
      <item id="spod-crdcount" lbl="nevenschikkingen met aantal coördinatoren (minimaal 1)">
        select crd, count(crd) as aantal
        from (
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          with n, count(r) as crd
          return crd
        ) as foo
        group by crd
        order by crd
      </item>
      <item id="spod-crd0" lbl="nevenschikkingen zonder coördinator">
        <item id="spod-crd0-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})
          optional match (n)-[r:rel{rel: 'crd'}]->()
          with n, r
          where r is null
          return n.sentid, n.id
        </item>
        <item id="spod-crd0-tel" lbl="telling">
          match (n:node{cat: 'conj'})
          optional match (n)-[r:rel{rel: 'crd'}]->()
          with n, r
          where r is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-crd1" lbl="nevenschikkingen met 1 coördinator">
        <item id="spod-crd1-zin" lbl="zinnen">
          match p = (:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          with p, count(r) as cnt
          where cnt = 1
          return p
        </item>
        <item id="spod-crd1-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          with n, count(r) as cnt
          where cnt = 1
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-crd1en" lbl="nevenschikkingen met 1 coördinator, en dat is &quot;en&quot;">
        <item id="spod-crd1en-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'en'})
          with n, w, count(r) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-crd1en-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'en'})
          with n, w, count(r) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-crd1of" lbl="nevenschikkingen met 1 coördinator, en dat is &quot;of&quot;">
        <item id="spod-crd1of-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'of'})
          with n, w, count(r) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-crd1of-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'of'})
          with n, w, count(r) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-crd1maa" lbl="nevenschikkingen met 1 coördinator, en dat is &quot;maar&quot;">
        <item id="spod-crd1maa-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'maar'})
          with n, w, count(r) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-crd1maa-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'maar'})
          with n, w, count(r) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-crd1enz" lbl="nevenschikkingen met 1 coördinator, en de coordinator sluit de nevenschikking af (&quot;enzovoorts&quot;)">
        <item id="spod-crd1enz-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(x:nw)
          with n, x, count(r) as cnt
          where cnt = 1 and x.end = n.end
          return n.sentid, n.id, x.id
        </item>
        <item id="spod-crd1enz-tel" lbl="telling">
            match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
            optional match (n)-[:rel{rel: 'crd'}]->(x:nw)
            with n, x, count(r) as cnt
            where cnt = 1 and x.end = n.end
            with distinct n.sentid as sentid, n.id as id
            return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-crd2" lbl="nevenschikkingen met 2 coördinatoren">
        <item id="spod-crd2-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          with n, count(r) as cnt
          where cnt = 2
          return n.sentid, n.id
        </item>
        <item id="spod-crd2-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          with n, count(r) as cnt
          where cnt = 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-crd2p" lbl="nevenschikkingen met meer dan 2 coördinatoren">
        <item id="spod-crd2p-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          with n, count(r) as cnt
          where cnt > 2
          return n.sentid, n.id
        </item>
        <item id="spod-crd2p-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'crd'}]->()
          with n, count(r) as cnt
          where cnt > 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-crd22" lbl="reeksvormers (nevenschikkingen van de vorm crd,cnj,crd,cnj...)">
        <item id="spod-crd22-zin" lbl="zinnen">
          -- Dit werkt niet optimaal. Sommige reeksen worden niet gevonden.

          match (n1:nw)&lt;-[:rel{rel:'crd'}]-(n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->(n3:nw)
          match (n2:nw{sentid: n.sentid})&lt;-[:rel{rel:'cnj'}]-(n)-[:rel{rel: 'cnj'}]->(n4:nw)
          where n1.id = n.id + 1
          and (
                n1.id &lt; n2.id
            and n2.id &lt; n3.id
            and n3.id &lt; n4.id
            or
                n1.begin &lt; n2.begin
            and n2.begin &lt; n3.begin
            and n3.begin &lt; n4.begin
          )
          return n
        </item>
        <item id="spod-crd22-tel" lbl="telling">
          -- Dit werkt niet optimaal. Sommige reeksen worden niet gevonden.

          match (n1:nw)&lt;-[:rel{rel:'crd'}]-(n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->(n3:nw)
          match (n2:nw{sentid: n.sentid})&lt;-[:rel{rel:'cnj'}]-(n)-[:rel{rel: 'cnj'}]->(n4:nw)
          where n1.id = n.id + 1
          and (
                n1.id &lt; n2.id
            and n2.id &lt; n3.id
            and n3.id &lt; n4.id
            or
                n1.begin &lt; n2.begin
            and n2.begin &lt; n3.begin
            and n3.begin &lt; n4.begin
          )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cnjcount" lbl="nevenschikkingen met aantal conjuncten (minimaal 1)">
        select cnj, count(cnj) as aantal
        from (
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnj
          return cnj
        ) as foo
        group by cnj
        order by cnj
      </item>
      <item id="spod-cnj1" lbl="nevenschikkingen met slechts 1 conjunct">
        <item id="spod-cnj1-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 1
          return n.sentid, n.id
        </item>
        <item id="spod-cnj1-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 1
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cnj2" lbl="nevenschikkingen met 2 conjuncten">
        <item id="spod-cnj2-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 2
          return n.sentid, n.id
        </item>
        <item id="spod-cnj2-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cnj3" lbl="nevenschikkingen met 3 conjuncten">
        <item id="spod-cnj3-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 3
          return n.sentid, n.id
        </item>
        <item id="spod-cnj3-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 3
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cnj4" lbl="nevenschikkingen met 4 conjuncten">
        <item id="spod-cnj4-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 4
          return n.sentid, n.id
        </item>
        <item id="spod-cnj4-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 4
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cnj5" lbl="nevenschikkingen met 5 conjuncten">
        <item id="spod-cnj5-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 5
          return n.sentid, n.id
        </item>
        <item id="spod-cnj5-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 5
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cnj6" lbl="nevenschikkingen met 6 conjuncten">
        <item id="spod-cnj6-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 6
          return n.sentid, n.id
        </item>
        <item id="spod-cnj6-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt = 6
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cnj6p" lbl="nevenschikkingen met meer dan 6 conjuncten">
        <item id="spod-cnj6p-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt > 6
          return n.sentid, n.id
        </item>
        <item id="spod-cnj6p-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[r:rel{rel: 'cnj'}]->()
          with n, count(r) as cnt
          where cnt > 6
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-cnjnp" lbl="nevenschikking van NP's">
        <item id="spod-cnjnp-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{_np: true})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2._np is null
          return n.sentid, n.id
        </item>
        <item id="spod-cnjnp-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{_np: true})
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where n2._np is null
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-cnjpp" lbl="nevenschikking van PP's">
        <item id="spod-cnjpp-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'pp'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'pp'
          return n.sentid, n.id
        </item>
        <item id="spod-cnjpp-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
           match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'pp'})
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where n2.cat is null or n2.cat != 'pp'
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-cnjmain" lbl="nevenschikking van hoofdzinnen">
        <item id="spod-cnjmain-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'smain'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'smain'
          return n.sentid, n.id
        </item>
        <item id="spod-cnjmain-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'smain'})
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where n2.cat is null or n2.cat != 'smain'
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-cnjvp" lbl="nevenschikking van VP">
        <item id="spod-cnjvp-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n1:nw)
          where n1.cat in ['ssub','ti','ppart','inf']
             or n1.pt = 'ww'
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where not ( n2.cat is not null and n2.cat in ['ssub','ti','ppart','inf']
             or n2.pt is not null and n2.pt = 'ww' )
          return n.sentid, n.id
        </item>
        <item id="spod-cnjvp-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n1:nw)
            where n1.cat in ['ssub','ti','ppart','inf']
               or n1.pt = 'ww'
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where not ( n2.cat is not null and n2.cat in ['ssub','ti','ppart','inf']
               or n2.pt is not null and n2.pt = 'ww' )
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-cnjcp" lbl="nevenschikking van bijzinnen">
        <item id="spod-cnjcp-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'cp'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'cp'
          return n.sentid, n.id
        </item>
        <item id="spod-cnjcp-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'cp'})
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where n2.cat is null or n2.cat != 'cp'
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
    </item>

    <item id="spod-wgroep" lbl="Woordgroepen">
      <item id="spod-np" lbl="np">
        <item id="spod-np-zin" lbl="zinnen">
          match (x:nw{_np: true})
          return x.sentid, x.id
        </item>
        <item id="spod-np-tel" lbl="telling">
          match (x:nw{_np: true})
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-pp" lbl="pp">
        <item id="spod-pp-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})
          return n.sentid, n.id
        </item>
        <item id="spod-pp-tel" lbl="telling">
          match (n:node{cat: 'pp'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ap" lbl="ap">
        <item id="spod-ap-zin" lbl="zinnen">
          match (x:nw)&lt;-[r:rel]-()
          where (x.cat is not null and x.cat = 'ap')
             or (x.pt is not null and x.pt = 'adj')
            and r.rel != 'hd'
          return x.sentid, x.id
        </item>
        <item id="spod-ap-tel" lbl="telling">
          match (x:nw)&lt;-[r:rel]-()
          where (x.cat is not null and x.cat = 'ap')
             or (x.pt is not null and x.pt = 'adj')
            and r.rel != 'hd'
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-advp" lbl="advp">
        <item id="spod-advp-zin" lbl="zinnen">
          match (x:nw)&lt;-[r:rel]-()
          where (x.cat is not null and x.cat = 'advp')
             or (x.pt is not null and x.pt = 'bw')
            and r.rel != 'hd'
          return x.sentid, x.id
        </item>
        <item id="spod-advp-tel" lbl="telling">
          match (x:nw)&lt;-[r:rel]-()
          where (x.cat is not null and x.cat = 'advp')
             or (x.pt is not null and x.pt = 'bw')
            and r.rel != 'hd'
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>

    </item>

    <item id="spod-ppgroep" lbl="Voorzetselgroepen">
      <item id="spod-ppnp" lbl="grammaticale functie, bepalingen bij zelfstandige naamwoorden">
        <item id="spod-ppnp-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(:node{cat: 'np'})
          return n.sentid, n.id
        </item>
        <item id="spod-ppnp-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(:node{cat: 'np'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ppap" lbl="grammaticale functie, bepalingen bij adjectieven (en als adjectief gebruikte deelwoorden)">
        <item id="spod-ppap-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n2:node{cat:'ap'})
          return n.sentid, n.id
          union
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n2:node)
          where n2.cat in ['ppart','ppres']
            and not exists((n2)&lt;-[:rel{rel: 'vc'}]-())
            and not exists((n2)&lt;-[:rel{rel: 'cnj'}]-()&lt;-[:rel{rel: 'vc'}]-())
          return n.sentid, n.id
        </item>
        <item id="spod-ppap-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n2:node{cat:'ap'})
            return distinct n.sentid, n.id
            union
            match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n2:node)
            where n2.cat in ['ppart','ppres']
              and not exists((n2)&lt;-[:rel{rel: 'vc'}]-())
              and not exists((n2)&lt;-[:rel{rel: 'cnj'}]-()&lt;-[:rel{rel: 'vc'}]-())
            return distinct n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-pppc" lbl="grammaticale functie, voorzetselvoorwerp">
        <item id="spod-pppc-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'pc'}]-()
          return n.sentid, n.id
        </item>
        <item id="spod-pppc-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'pc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ppld" lbl="grammaticale functie, locatief/directioneel complement">
        <item id="spod-ppld-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'ld'}]-()
          return n.sentid, n.id
        </item>
        <item id="spod-ppld-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'ld'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-pppredc" lbl="grammaticale functie, predicatief complement">
        <item id="spod-pppredc-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'predc'}]-()
          return n.sentid, n.id
        </item>
        <item id="spod-pppredc-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'predc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ppbep" lbl="grammaticale functie, bijwoordelijke bepaling">
        <item id="spod-ppbep-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n1)&lt;-[r:rel]-(n2)
          where n1.cat in ['smain','sv1','whq','ssub','inf']
             or (
               n1.cat = 'ppart'
               and (
                 r.rel = 'vc'
                 or (
                   r.rel = 'cnj'
                   and exists((n2)&lt;-[:rel{rel: 'vc'}]-())
                )
              )
            )
          return n.sentid, n.id
        </item>
        <item id="spod-ppbep-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n1)&lt;-[r:rel]-(n2)
          where n1.cat in ['smain','sv1','whq','ssub','inf']
             or (
               n1.cat = 'ppart'
               and (
                 r.rel = 'vc'
                 or (
                   r.rel = 'cnj'
                   and exists((n2)&lt;-[:rel{rel: 'vc'}]-())
                )
              )
            )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ppinp" lbl="interne structuur, P + NP">
        <item id="spod-ppinp-zin" lbl="zinnen">
          match (n1)&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(n2)
          where n1.begin = n.begin and n2.end = n.end
          return n.sentid, n.id
        </item>
        <item id="spod-ppinp-tel" lbl="telling">
          match (n1)&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(n2)
          where n1.begin = n.begin and n2.end = n.end
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ppirp" lbl="interne structuur, +R-pronomen + P">
        <item id="spod-ppirp-zin" lbl="zinnen">
          match (n1)&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(w:word{pt: 'vnw'})
          where w.begin = n.begin and n1.end = n.end
          return n.sentid, n.id
        </item>
        <item id="spod-ppirp-tel" lbl="telling">
          match (n1)&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(w:word{pt: 'vnw'})
          where w.begin = n.begin and n1.end = n.end
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-ppimwu" lbl="interne structuur, complex voorzetsel">
        <item id="spod-ppimwu-zin" lbl="zinnen">
          match (:node{cat: 'mwu'})&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})
          return n.sentid, n.id
        </item>
        <item id="spod-ppimwu-tel" lbl="telling">
          match (:node{cat: 'mwu'})&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
    </item>

    <item id="spod-ww" lbl="Werkwoorden">
      <item id="spod-vwuit" lbl="vaste werkwoordelijke uitdrukkingen">
        <item id="spod-vwuit-zin" lbl="zinnen">
          match (n:node)&lt;-[:rel{rel: 'svp'}]-()
          where n.cat is not null
          return n.sentid, n.id
        </item>
        <item id="spod-vwuit-tel" lbl="telling">
          match (n:node)&lt;-[:rel{rel: 'svp'}]-()
          where n.cat is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-groen" lbl="groene werkwoordsvolgorde">
        <item id="spod-groen-zin" lbl="zinnen">
          match (w:word{wvorm: 'vd'})&lt;-[:rel{rel: 'hd'}]-(:node)&lt;-[:rel{rel: 'vc'}]-(:node)-[:rel{rel: 'hd'}]->(x)
          where w.begin &lt; x.begin
            and not exists( (w)&lt;-[:rel*2]-(:node{sentid: w.sentid, cat: 'smain'}) )
            and not exists( (w)&lt;-[:rel*2]-(:node{sentid: w.sentid, cat: 'sv1'}) )
          return w.sentid, w.id
        </item>
        <item id="spod-groen-tel" lbl="telling">
          match (w:word{wvorm: 'vd'})&lt;-[:rel{rel: 'hd'}]-(:node)&lt;-[:rel{rel: 'vc'}]-(:node)-[:rel{rel: 'hd'}]->(x)
          where w.begin &lt; x.begin
            and not exists( (w)&lt;-[:rel*2]-(:node{sentid: w.sentid, cat: 'smain'}) )
            and not exists( (w)&lt;-[:rel*2]-(:node{sentid: w.sentid, cat: 'sv1'}) )
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-rood" lbl="rode werkwoordsvolgorde">
        <item id="spod-rood-zin" lbl="zinnen">
          match (n:word{wvorm: 'vd'})&lt;-[:rel{rel: 'hd'}]-()&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          optional match (n)&lt;-[:rel]-()&lt;-[:rel]-(n2:node{cat: 'smain'})
          optional match (n)&lt;-[:rel]-()&lt;-[:rel]-(n3:node{cat: 'sv1'})
          with n, n2, n3, w
          where n.begin > w.begin
            and n2 is null
            and n3 is null
          return n.sentid, n.id
        </item>
        <item id="spod-rood-tel" lbl="telling">
          match (n:word{wvorm: 'vd'})&lt;-[:rel{rel: 'hd'}]-()&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          optional match (n)&lt;-[:rel]-()&lt;-[:rel]-(n2:node{cat: 'smain'})
          optional match (n)&lt;-[:rel]-()&lt;-[:rel]-(n3:node{cat: 'sv1'})
          with n, n2, n3, w
          where n.begin > w.begin
            and n2 is null
            and n3 is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-wwclus" lbl="werkwoordsclusters">
        <item id="spod-wwclus-zin" lbl="zinnen">
          match (n1:nw)&lt;-[:rel]-(n:node)&lt;-[:rel{rel: 'vc'}]-(n0:node)-[:rel{rel: 'hd'}]->(n2:word{pt: 'ww'})
          where n.cat in ['ti','inf','ppart']
            and not(n0.cat in ['smain','sv1']) -- dit hoeft niet per se n0 te zijn???
            and n1.begin &lt; n2.begin
          return n.sentid, n.id
        </item>
        <item id="spod-wwclus-tel" lbl="telling">
          match (n1:nw)&lt;-[:rel]-(n:node)&lt;-[:rel{rel: 'vc'}]-(n0:node)-[:rel{rel: 'hd'}]->(n2:word{pt: 'ww'})
          where n.cat in ['ti','inf','ppart']
            and not(n0.cat in ['smain','sv1']) -- dit hoeft niet per se n0 te zijn???
            and n1.begin &lt; n2.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-accinf" lbl="accusativus cum infinitivo">
        <item id="spod-accinf-zin" lbl="zinnen">
          -- niet voor Corpus Gesproken Nederlands

          match (x)&lt;-[:rel]-(n:node{cat: 'inf'})&lt;-[:rel{rel: 'vc'}]-(n1)-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          match (n)-[:rel{rel: 'su'}]->()&lt;-[:rel{rel: 'obj1'}]-(n1)
          where not n1.cat in ['smain','sv1']
            and x.begin &lt; w.begin
          return n.sentid, n.id
        </item>
        <item id="spod-accinf-tel" lbl="telling">
          -- niet voor Corpus Gesproken Nederlands

          match (x)&lt;-[:rel]-(n:node{cat: 'inf'})&lt;-[:rel{rel: 'vc'}]-(n1)-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          match (n)-[:rel{rel: 'su'}]->()&lt;-[:rel{rel: 'obj1'}]-(n1)
          where not n1.cat in ['smain','sv1']
            and x.begin &lt; w.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-passive" lbl="passief">
        <item id="spod-passive-zin" lbl="zinnen">
          -- niet voor Corpus Gesproken Nederlands

          match (n1:nw)&lt;-[:rel{rel: 'obj1'}]-()&lt;-[r:rel*0..1]-(n:node)&lt;-[:rel{rel: 'vc'}]-()&lt;-[:rel]-(n0)
          match (n0)-[:rel{rel: 'su'}]->(n1)
          where (length(r) = 0 and n.cat = 'ppart' or length(r) = 1 and n.cat = 'ti')
          return n.sentid, n.id
        </item>
        <item id="spod-passive-tel" lbl="telling">
          -- niet voor Corpus Gesproken Nederlands

          match (n1:nw)&lt;-[:rel{rel: 'obj1'}]-()&lt;-[r:rel*0..1]-(n:node)&lt;-[:rel{rel: 'vc'}]-()&lt;-[:rel]-(n0)
          match (n0)-[:rel{rel: 'su'}]->(n1)
          where (length(r) = 0 and n.cat = 'ppart' or length(r) = 1 and n.cat = 'ti')
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-nppas" lbl="niet-persoonlijke passief">
        <item id="spod-nppas-zin" lbl="zinnen">
          -- niet voor Corpus Gesproken Nederlands

          match (n:nw)&lt;-[:rel{rel: 'vc'}]-()
          match (n)&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(n1)
          match (n)&lt;-[:rel]-(n2)
          optional match (pn:node{cat: 'sv1'})-[:rel]->(n)
          optional match (pn)-[:rel{rel: 'su'}]->(px1)
          optional match (pn)-[:rel{rel: 'hd'}]->(px2)
          with n, n1, n2, pn, px1, px2
          where (n1.sc in ['passive','te_passive']
            or (n1.pt = 'ww'
               and (
                 ( n.cat = 'ppart'
                   and not exists ((n)-[:rel{rel: 'obj1'}]->())
                   and not exists ((n)-[:rel{rel: 'su'}]->())
                   and not exists ((n)-[:rel{rel: 'vc'}]->())
                   and not exists ((n)-[:rel{rel: 'predc'}]->()) )
                 or ( n.cat = 'ti'
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'obj1'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'su'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'vc'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'predc'}]->()) )
               ))
            ) and (
            -- n2 is een parent van n
            not exists((n2)-[:rel{rel: 'su'}]->())
            and (
              n2.cat in ['smain','ssub']
              or (
                n2.cat = 'sv1'
                and not (
                  -- imperatief
                  pn is not null
                    and px1 is null
                    and not (px2.stype   is not null and not px2.stype = 'imparative')
                    and not ((px2.tense  is not null and px2.tense = 'past') or
                             (px2.pvagr  is not null and px2.pvagr in ['mv','met-t']) or
                             (px2.pvtijd is not null and px2.pvtijd = 'verl') or
                             (px2.lemma  is not null and px2.lemma in ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben']) )
                  -- einde imperatief
                )))
          )
          return n.sentid, n.id
        </item>
        <item id="spod-nppas-tel" lbl="telling">
          -- niet voor Corpus Gesproken Nederlands

          match (n:nw)&lt;-[:rel{rel: 'vc'}]-()
          match (n)&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(n1)
          match (n)&lt;-[:rel]-(n2)
          optional match (pn:node{cat: 'sv1'})-[:rel]->(n)
          optional match (pn)-[:rel{rel: 'su'}]->(px1)
          optional match (pn)-[:rel{rel: 'hd'}]->(px2)
          with n, n1, n2, pn, px1, px2
          where (n1.sc in ['passive','te_passive']
             or (n1.pt = 'ww'
               and (
                 ( n.cat = 'ppart'
                   and not exists ((n)-[:rel{rel: 'obj1'}]->())
                   and not exists ((n)-[:rel{rel: 'su'}]->())
                   and not exists ((n)-[:rel{rel: 'vc'}]->())
                   and not exists ((n)-[:rel{rel: 'predc'}]->()) )
                 or ( n.cat = 'ti'
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'obj1'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'su'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'vc'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'predc'}]->()) )
               ))
          ) and (
            -- n2 is een parent van n
            not exists((n2)-[:rel{rel: 'su'}]->())
            and (
              n2.cat in ['smain','ssub']
              or (
                n2.cat = 'sv1'
                and not (
                  -- imperatief
                  pn is not null
                    and px1 is null
                    and not (px2.stype   is not null and not px2.stype = 'imparative')
                    and not ((px2.tense  is not null and px2.tense = 'past') or
                             (px2.pvagr  is not null and px2.pvagr in ['mv','met-t']) or
                             (px2.pvtijd is not null and px2.pvtijd = 'verl') or
                             (px2.lemma  is not null and px2.lemma in ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben']) )
                  -- einde imperatief
                )))
          )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
    </item>

    <item id="spod-wwsch" lbl="Scheidbare werkwoorden">
      <item id="spod-vpart" lbl="Werkwoorden met een scheidbaar partikel">
        <item id="spod-vpart-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          return w.sentid, w.id
        </item>
        <item id="spod-vpart-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-vpartex" lbl="Werkwoorden met een scheidbaar partikel, partikel gescheiden van het werkwoord">
        <item id="spod-vpartex-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and w2.frame starts with 'particle'
          return w.sentid, w.id
        </item>
        <item id="spod-vpartex-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and w2.frame starts with 'particle'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-vpartin" lbl="Werkwoorden met een scheidbaar partikel, partikel geïncorporeerd in het werkwoord">
        <item id="spod-vpartin-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          return w.sentid, w.id
          except
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and w2.frame starts with 'particle'
          return w.sentid, w.id
        </item>
        <item id="spod-vpartin-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (w:word)
            where w.sc starts with 'part_'
            return distinct w.sentid, w.id
            except
            match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
            where w.sc starts with 'part_'
              and w2.frame starts with 'particle'
            return distinct w.sentid, w.id
          ) as foo
        </item>
      </item>
      <item id="spod-vprtn" lbl="Niet-finiete werkwoorden met een scheidbaar partikel">
        <item id="spod-vprtn-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
          return w.sentid, w.id
        </item>
        <item id="spod-vprtn-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-vprtnex" lbl="Niet-finiete werkwoorden met een scheidbaar partikel, partikel gescheiden van het werkwoord">
        <item id="spod-vprtnex-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
            and w2.frame starts with 'particle'
          return w.sentid, w.id
        </item>
        <item id="spod-vprtnex-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
            and w2.frame starts with 'particle'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-vprtnin" lbl="Niet-finiete werkwoorden met een scheidbaar partikel, partikel geïncorporeerd in het werkwoord">
        <item id="spod-vprtnin-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
          return w.sentid, w.id
          except
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
            and w2.frame starts with 'particle'
          return w.sentid, w.id
        </item>
        <item id="spod-vprtnin-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (w:word)
            where w.sc starts with 'part_'
              and (w.wvorm is null or w.wvorm != 'pv')
            return distinct w.sentid, w.id
            except
            match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
            where w.sc starts with 'part_'
              and (w.wvorm is null or w.wvorm != 'pv')
              and w2.frame starts with 'particle'
            return distinct w.sentid, w.id
          ) as foo
        </item>
      </item>
    </item>

    <item id="spod-inb" lbl="Inbedding">
      <item id="spod-inb-all" lbl="telling van alle niveaus">
        match (n:node{_clause: true})
        optional match (n)-[:rel*1..]->(n2:node{sentid:n.sentid, _clause: true})
        with n, n2
        where n2 is null
        return n._clause_lvl - 1 as niveau, count(n._clause_lvl) as aantal
        order by niveau
      </item>
      <item id="spod-inb0" lbl="geen inbedding">
        match (n:node{_clause_lvl: 1})
        optional match (n)-[:rel*1..]->(n2:node{sentid:n.sentid, _clause: true})
        with n, n2
        where n2 is null
        return n
      </item>
      <item id="spod-inb1" lbl="minstens 1 finiete zinsinbedding">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 1
        return p
      </item>
      <item id="spod-inb2" lbl="minstens 2 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 2
        return p
      </item>
      <item id="spod-inb3" lbl="minstens 3 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 3
        return p
      </item>
      <item id="spod-inb4" lbl="minstens 4 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 4
        return p
      </item>
      <item id="spod-inb5" lbl="minstens 5 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 5
        return p
      </item>
      <item id="spod-inb6" lbl="minstens 6 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 6
        return p
      </item>
      <item id="spod-inb7" lbl="minstens 7 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 7
        return p
      </item>
      <item id="spod-inb8" lbl="minstens 8 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 8
        return p
      </item>
    </item>

    <item id="sod-topiextr" lbl="Topicalisatie en Extractie">
      <item id="spod-nptsub" lbl="np-topic is subject">
        <item id="spod-nptsub-zin" lbl="zinnen">
          match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
          where r.rel in ['su','sup'] and r.id is null
          return n.sentid, n.id
        </item>
        <item id="spod-nptsub-tel" lbl="telling">
          match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
          where r.rel in ['su','sup'] and r.id is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
      <item id="spod-nptnsub" lbl="np-topic is geen subject">
        <item id="spod-nptnsub-zin" lbl="zinnen">
          match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
          where r.id is null
          return n.sentid, n.id
          except
          match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
          where r.id is null and r.rel in ['su','sup']
          return n.sentid, n.id
        </item>
        <item id="spod-nptnsub-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
            where r.id is null
            return distinct n.sentid, n.id
            except
            match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
            where r.id is null and r.rel in ['su','sup']
            return distinct n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-tnonloc" lbl="topic is niet lokaal">
        <item id="spod-tnonloc-zin" lbl="zinnen">
          match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
          where r.id is null
          return n.sentid, n.id
          except
          match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
          match (n)-[:rel*1..]->(n0:node{sentid: n.sentid})-[r2:rel]->()-[:rel*0..]->(:nw{sentid: n.sentid, _vorfeld: true})
          where r.id is null and r2.id is null and n0.cat in ['ssub','smain']
          return n.sentid, n.id
        </item>
        <item id="spod-tnonloc-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
            where r.id is null
            return distinct n.sentid, n.id
            except
            match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
            match (n)-[:rel*1..]->(n0:node{sentid: n.sentid})-[r2:rel]->()-[:rel*0..]->(:nw{sentid: n.sentid, _vorfeld: true})
            where r.id is null and r2.id is null and n0.cat in ['ssub','smain']
            return distinct n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-locext" lbl="lokale extractie">
        <item id="spod-locext-zin" lbl="zinnen">
          match (n:nw)&lt;-[r:rel]-()
          where r.rel in ['whd','rhd']
          return n.sentid, n.id
          except
          match (n:nw)&lt;-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid: n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)&lt;-[:rel]-()&lt;-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
            and n2 is null
          return n.sentid, n.id
        </item>
        <item id="spod-locext-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(sentid) as items
          from (
            match (n:nw)&lt;-[r:rel]-()
            where r.rel in ['whd','rhd']
            return distinct n.sentid, n.id
            except
            match (n:nw)&lt;-[r:rel]-(nn)
            match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid: n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
            optional match (n0)&lt;-[:rel]-()&lt;-[:rel{rel: 'obcomp'}]-(n2)
            with r, n, n0, n2
            where r.rel in ['whd','rhd']
              and n2 is null
            return distinct n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-nlocext" lbl="niet-lokale extractie">
        <item id="spod-nlocext-zin" lbl="zinnen">
          match (n:nw)&lt;-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid: n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)&lt;-[:rel]-()&lt;-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
            and n2 is null
          return n.sentid, n.id
        </item>
        <item id="spod-nlocext-tel" lbl="telling">
          match (n:nw)&lt;-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid: n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)&lt;-[:rel]-()&lt;-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
            and n2 is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(sentid) as items
        </item>
      </item>
    </item>

    <item id="spod-parser" lbl="Parser succes">
      <item id="spod-ok" lbl="volledige parse">
        <item id="spod-ok-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1, skips:0})
          return s
        </item>
        <item id="spod-ok-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1, skips:0})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-catcount" lbl="aantal geparste delen">
        -- alleen voor automatisch verwerkte corpora

        match (s:sentence)
        where s.cats is not null
        return s.cats as delen, count(s.cats) as zinnen
        order by delen
      </item>
      <item id="spod-cats0" lbl="geen enkel deel is geparst">
        <item id="spod-cats0-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:0})
          return s
        </item>
        <item id="spod-cats0-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:0})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-cats1" lbl="parse bestaat uit één deel">
        <item id="spod-cats1-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1})
          return s
        </item>
        <item id="spod-cats1-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-cats2" lbl="parse bestaat uit twee losse delen">
        <item id="spod-cats2-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:2})
          return s
        </item>
        <item id="spod-cats2-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:2})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-cats3" lbl="parse bestaat uit drie losse delen">
        <item id="spod-cats3-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:3})
          return s
        </item>
        <item id="spod-cats3-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:3})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-cats4" lbl="parse bestaat uit vier of meer losse delen">
        <item id="spod-cats4-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.cats > 3
          return s
        </item>
        <item id="spod-cats4-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.cats > 3
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-skipcount" lbl="aantal overgeslagen woorden">
        -- alleen voor automatisch verwerkte corpora

        match (s:sentence)
        where s.skips is not null
        return s.skips as &quot;overgeslagen woorden&quot;, count(s.skips) as zinnen
        order by &quot;overgeslagen woorden&quot;
      </item>
      <item id="spod-skips0" lbl="geen enkel woord is overgeslagen">
        <item id="spod-skips0-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:0})
          return s
        </item>
        <item id="spod-skips0-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:0})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-skips1" lbl="een van de woorden is overgeslagen">
        <item id="spod-skips1-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:1})
          return s
        </item>
        <item id="spod-skips1-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:1})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-skips2" lbl="twee van de woorden zijn overgeslagen">
        <item id="spod-skips2-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:2})
          return s
        </item>
        <item id="spod-skips2-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:2})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-skips3" lbl="drie van de woorden zijn overgeslagen">
        <item id="spod-skips3-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:3})
          return s
        </item>
        <item id="spod-skips3-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:3})
          return count(s) as zinnen
        </item>
      </item>
      <item id="spod-skips4" lbl="vier of meer van de woorden zijn overgeslagen">
        <item id="spod-skips4-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.skips > 3
          return s
        </item>
        <item id="spod-skips4-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.skips > 3
          return count(s) as zinnen
        </item>
      </item>
    </item>

    <item id="spod-onbekend" lbl="Onbekende woorden">
      <item id="spod-his" lbl="&quot;alle&quot; woorden (nodes met attribuut @his)">
        <item id="spod-his-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
          return w
        </item>
        <item id="spod-his-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
          return count(w) as woorden
        </item>
      </item>
      <item id="spod-normal" lbl="woorden uit het woordenboek of de namenlijst">
        <item id="spod-normal-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'normal'})
          return w
        </item>
        <item id="spod-normal-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'normal'})
          return count(w) as woorden
        </item>
      </item>
      <item id="spod-onbeken" lbl="woorden niet direct uit het woordenboek">
        <item id="spod-onbeken-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
            and not (w.his in ['normal','robust_skip','skip'])
          return w
        </item>
        <item id="spod-onbeken-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
            and not (w.his in ['normal','robust_skip','skip'])
          return count(w) as woorden
        </item>
      </item>
      <item id="spod-compoun" lbl="woorden herkend als samenstelling">
        <item id="spod-compoun-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'compound'})
          return w
        </item>
        <item id="spod-compoun-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'compound'})
          return count(w) as woorden
        </item>
      </item>
      <item id="spod-name" lbl="woorden herkend als naam (maar niet uit namenlijst)">
        <item id="spod-name-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'name'})
          return w
        </item>
        <item id="spod-name-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'name'})
          return count(w) as woorden
        </item>
      </item>
      <item id="spod-noun" lbl="onbekende woorden die niet als samenstelling of naam werden herkend">
        <item id="spod-noun-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
            and not (w.his in ['normal','compound','name','robust_skip','skip'])
          return w
        </item>
        <item id="spod-noun-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
            and not (w.his in ['normal','compound','name','robust_skip','skip'])
          return count(w) as woorden
        </item>
      </item>
    </item>

  </item>

</menu>
