<?xml version="1.0" encoding="UTF-8"?>
<menu>

  <item id="tut" lbl="Voorbeelden">
    <item id="tut-inl" lbl="Inleiding">
      <item id="tut-inl-node" lbl="Node">
        -- Een vertex in de graaf dat geen woord is
        -- (of een multi-word unit)

        match (n:node)
        return n
        limit 10
      </item>
      <item id="tut-inl-word" lbl="Woord">
        match (w:word)
        return w
        limit 10
      </item>
      <item id="tut-inl-nw" lbl="Node of woord">
        -- :nw is een alias voor :node en :word samen

        match (n:nw)
        return n
        limit 10
      </item>
      <item id="tut-inl-zin" lbl="Zin">
        match (s:sentence)
        return s
        limit 10
      </item>
      <item id="tut-inl-meta" lbl="Metadata">
        match (m:meta)
        return m.sentid as "sentence ID", m.type, m.name, m.value
        limit 10
      </item>
      <item id="tut-inl-attr" lbl="Attributen">
        -- Tellingen van verschillende soorten attributen

        match (f:feature)
        return f
        limit 10
      </item>
      <item id="tut-inl-rel" lbl="Relatie">
        match ()-[r]->()
        return r
        limit 10
      </item>
      <item id="tut-inl-roor" lbl="Root">
        -- :sentence fungeert als root voor verschillende soorten relaties

        match (:sentence)-[r]->()
        return r
        limit 10
      </item>
      <item id="tut-inl-corpus" lbl="Datainvoer">
        -- extra informatie toegevoegd bij het inlezen van het corpus

        match (d:doc)
        return d
      </item>
    </item>
    <item id="tut-next" lbl="Woorden en woordgroepen">
      <item id="tut-next-next" lbl="De next-relatie">
        -- De relatie :next verbindt twee opeenvolgende woorden met elkaar

        match p = ()-[:next]->()
        return p
      </item>
      <item id="tut-next-first" lbl="De eerste twee woorden van de zin">
        match p = (:word{begin:0})-[:next]->()
        return p
      </item>
      <item id="tut-next-last" lbl="De laatste twee woorden van de zin">
        match p = ()-[:next]->(:word{last:true})
        return p
      </item>
      <item id="tut-next-woorden" lbl="Woorden in dezelfde zin">
        -- Zoek zinnen met zowel 'dag' als 'jaar'

        match (w1:word{lemma: 'dag'}),
              (w2:word{sentid: w1.sentid, lemma: 'jaar'})
        return w1, w2
      </item>
      <item id="tut-next-near" lbl="Woorden bij elkaar in de buurt">
        -- Zoek zinnen met zowel 'dag' als 'jaar'
        -- Maximaal twee andere woorden tussen 'dag' en 'jaar'
        -- Omdat de link geen richting bevat is de volgorde vrij

        match p = (:word{lemma: 'dag'})-[:next*1..3]-(:word{lemma: 'jaar'})
        return p
      </item>
      <item id="tut-next-groep" lbl="Woordgroepen">
        -- Welke woord volgt het vaakst na 'per'?

        match (:word{lemma: 'per'})-[:next]->(w:word)
        return w.lemma, count(*) as aantal
        order by aantal desc
      </item>
      <item id="tut-next-mwu" lbl="Multi-word units">
        -- Een multi-word unit is de enige vertex van het type 'node' met de attributen 'word', 'lemma' en 'pt'
        -- De waarde voor 'pt' is altijd 'mwu', net als voor 'cat' in dit geval

        match (w:node{cat: 'mwu'})
        return w.word, count(*) as aantal
        order by aantal desc
      </item>
      <item id="tut-next-cp1" lbl="Compound parts (1)">
        -- Het attribuut '_cp' van een 'word' bevat de compound parts van het lemma

        match (w:word)
        where length(w._cp) > 1
        return w.lemma, count(*)
        order by count desc, lemma
      </item>
       <item id="tut-next-cp2" lbl="Compound parts (2)">
        -- Zoek woorden waarvan het lemma 'fiets' of 'fietsen' bevat

        match (w:word)
        where 'fiets' in w._cp
           or 'fietsen' in w._cp
        return w.word, count(*)
        order by count desc, word
      </item>
   </item>
    <item id="tut-pair" lbl="Woordpaar-relaties">
      <item id="tut-pair-pair" lbl="De pair-relatie">
        match p = (:word)-[:pair]->(:word)
        return p
      </item>
      <item id="tut-pair-graag" lbl="Wat doen we graag?">
        -- Werkwoorden met 'graag' als modifier

        match p = (:nw{pt: 'ww'})-[:pair{rel: 'mod'}]->(:word{lemma: 'graag'})
        return p
      </item>
      <item id="tut-pair-eten" lbl="Wat wordt er gegeten?">
        -- Zelfstandig naamwoorden als 'obj1' van het werkwoord 'eten' of 'opeten'

        match (w1:word{pt: 'ww'})-[:pair{rel: 'obj1'}]->(w:word{pt: 'n'})
        where w1.lemma in ['eten', 'opeten']
        return w.lemma, count(*) as aantal
        order by aantal desc
      </item>
      <item id="tut-pair-obj12" lbl="Werkwoorden met lijdend voorwerp en meewerkend voorwerp">
        match (w1:nw)&lt;-[:pair{rel:'obj1'}]-(w:word{pt:'ww'})-[:pair{rel:'obj2'}]->(w2:nw)
        where w1.pt in ['n', 'mwu']
          and w2.pt in ['n', 'mwu']
        return w.lemma as werkwoord, w1.word as "lijdend voorwerp", w2.word as "meewerkend voorwerp"
      </item>
    </item>
    <item id="tut-rel" lbl="Alpino-structuren">
      <item id="tut-rel-attrib" lbl="Alpino-attributen: een onvoltooid deelwoord">
        match (w:word{wvorm:'od'})
        return w
      </item>
      <item id="tut-rel-conj" lbl="Alpino-attributen: een conjunctie">
        match (n:node{cat:'conj'})
        return n
      </item>
      <item id="tut-rel-nwords" lbl="Aantal woorden in een mededelende hoofdzin">
        match (n:node{cat: 'smain'})
        return n._n_words, count(*)
        order by _n_words
      </item>
      <item id="tut-rel-rel" lbl="De Alpino-relatie">
        match p = (:node)-[:rel]->(:nw)
        return p
      </item>
      <item id="tut-rel-rela" lbl="Relatieve zinsdelen">
        match p = (:node{cat:'rel'})-[:rel{rel:'body'}]->(:node{cat:'ssub'})
        return p
      </item>
      <item id="tut-rel-kind" lbl="Onderwerpen die het lemma 'kind' bevatten">
        match (:node)-[:rel{rel:'su'}]->(n:nw)-[:rel*0..]->(:word{lemma: 'kind'})
        return n
      </item>
      <item id="tut-rel-mwu-van" lbl="Multi-word units die eindigen met 'van'">
        match (n:node{cat:'mwu'})-[:rel{rel:'mwp'}]->(:word{lemma:'van', end:n.end})
        return n.word as "multi-word unit", count(*) as aantal
        order by aantal desc, "multi-word unit"
      </item>
      <item id="tut-rel-pdp" lbl="Node met twee parents">
        -- In Alpino kan een node maar één parent hebben
        -- In AlpinoGraph zijn nodes met een identieke index versmolten, waardoor
        --   een node meer dan één parent kan hebben

        match m = (n1:node)-[:rel]->()&lt;-[:rel]-(n2:node)
        where n1.id &lt; n2.id    -- voorkomt dubbelen
        return m
      </item>
    </item>
    <item id="tut-ud" lbl="Universal Dependencies">
      <item id="tut-ud-upos" lbl="Universal part-of-speech tag">
        match (w:word{upos:'NOUN'})
        return w
      </item>
      <item id="tut-ud-feat" lbl="Universal morphological features">
        -- Attributen met hoofdletters in de naam moeten tussen dubbele aanhalingstekens

        match (w:word{upos:'VERB'})
        return w."VerbForm", count(*)
      </item>
      <item id="tut-ud-ud" lbl="De standaard UD-relatie">
        match p = (:word)-[:ud]->(:word)
        return p
      </item>
      <item id="tut-ud-eud" lbl="De Enhanced UD-relatie">
        match p = (:word)-[:eud]->(:word)
        return p
      </item>
      <item id="tut-ud-dep" lbl="De dep-relatie">
        -- :dep is een alias voor :ud en :eud samen

        match p = (:word)-[:dep]->(:word)
        return p
      </item>
      <item id="tut-ud-nsubj" lbl="Onderwerp">
        match ()-[:ud{main:'nsubj'}]->(w)
        return w
      </item>
      <item id="tut-ud-pos" lbl="Possessieven">
        match (w1:word)-[:ud{rel:'nmod:poss'}]->(w2:word)
        return w1, w2
      </item>
      <item id="tud-ud-wwobj" lbl="Werkwoord met object dat geen persoonlijk voornaamwoord is">
          match (w1:word{upos:'VERB'})-[:ud{main:'obj'}]->(w2:word)
          where w2.upos != 'PRON'
          return w1, w2
      </item>
      <item id="tut-ud-reeks" lbl="Een advmod van een amod van een zelfstandig naamwoord">
        match p = (:word{upos:'NOUN'})-[:ud{main:'amod'}]->()-[:ud{main:'advmod'}]->()
        return p
      </item>
    </item>
    <item id="tut-mix" lbl="Heterogene relaties">
      <item id="tut-mix-udmwu" lbl="Universal Dependencies en multi-word units (1)">
        -- Universal dependencies zijn altijd tussen woorden
        -- Soms is dat met een woord dat het begin van een multi-word unit is
        --   en wil je de hele multi-word unit weten
        -- Daarvoor kun je UD-relaties [:ud] combineren met Alpino-relaties [:rel]

        match (:word{lemma:'gebruiken'})-[:ud{rel:'obj'}]->(v1:word)&lt;-[:rel*0..1{rel:'mwp'}]-(v)
        where not exists ( (v)&lt;-[:rel{rel:'mwp'}]-() )
        return v.lemma
      </item>
      <item id="tut-mix-udmwu2" lbl="Universal Dependencies en multi-word units (2)">
        -- Hier zoek je expliciet naar Universal Dependencies met een multi-word unit

        match (w:word)-[u:ud]->(:word)&lt;-[:rel]-(n:node{cat:'mwu'})
        where not u.main in ['flat','fixed']
        return w.lemma, u.rel, n.word
      </item>
      <item id="tut-mix-cop" lbl="Nominalisaties van copula-constructies">
        -- Voor de gevorderde taalkundige
        -- Ook hier wordt een UD-relatie gecombineerd met een Alpino-relatie

        match p = (:node{cat:'np'})-[:rel{rel:'hd'}]->(:word)&lt;-[:ud{main:'cop'}]-(:word)
        return p
      </item>
    </item>
    <item id="tut-meta" lbl="Metadata">
      <item id="tut-meta-zinnen" lbl="Aantal zinnen per land">
        -- Dit voorbeeld werk alleen met het Corpus Gesproken Nederlands

        match (m:meta{name: 'country'})
        return m.value as land, count(*) as "aantal zinnen"
      </item>
      <item id="tut-meta-woorden" lbl="Aantal woorden per land">
        -- Dit voorbeeld werk alleen met het Corpus Gesproken Nederlands

        match (w:word),
              (m:meta{sentid: w.sentid, name: 'country'})
        return m.value as land, count(*) as "aantal woorden"
      </item>
      <item id="tut-meta-gij" lbl="Waar wordt 'gij' gebruikt?">
        -- Dit voorbeeld werk alleen met het Corpus Gesproken Nederlands

        match (w:word{lemma: 'gij'}),
              (m:meta{sentid: w.sentid, name: 'country'})
        return m.value as land, count(*) as aantal
      </item>
      <item id="tut-meta-gij-perc" lbl="Genormaliseerd gebruik van 'gij'">
        -- Dit voorbeeld werk alleen met het Corpus Gesproken Nederlands

        select land,
               case when land ? 'BE' then aantal::text::numeric / 379916 -- aantal woorden in BE
                    when land ? 'NL' then aantal::text::numeric / 753845 -- aantal woorden in NL
                    else 0
               end as "per woord"
        from
        (
          match (w:word{lemma: 'gij'}),
                (m:meta{sentid: w.sentid, name: 'country'})
          return m.value as land, count(*) as aantal
        ) as foo
      </item>
    </item>
    <item id="software" lbl="Software">
      <item id="software-version" lbl="Versies">
        select version() as "PostgreSQL version", agversion() as "AgensGraph version"
      </item>
    </item>
  </item>

  <item id="idx" lbl="Corpusinformatie">
    <item id="idx-node" lbl="Attributen van nodes">
      match (f:feature{v: 'node'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    </item>
    <item id="idx-word" lbl="Attributen van woorden">
      match (f:feature{v: 'word'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    </item>
    <item id="idx-rel" lbl="Attributen van relaties">
      match (f:feature{v: 'rel'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    </item>
    <item id="idx-meta" lbl="Soorten metadata, indien aanwezig">
      match (f:feature{v: 'meta'})
      return f.name as metadata, f.count as aantal
      order by metadata
    </item>
    <item id="idx-doc" lbl="Bij de invoer van het corpus">
      match (d:doc)
      return d
    </item>
  </item>

  <item id="spod" lbl="SPOD">

    <item id="spod-info" lbl="Info" class="info">
      De *Syntactic profiler of Dutch* bestaat uit een grote set tests
      waarmee een profiel van een corpus kan worden opgesteld. SPOD is
      ontwikkeld in [PaQu](https://www.let.rug.nl/alfa/paqu/spod), en maakt
      gebruik van query's in XPath. Zie paper:
      > Gertjan van Noord, Jack Hoeksema, Peter Kleiweg, and Gosse Bouma. 2020. &lt;br>
      > [SPOD: Syntactic profiler of Dutch.](https://www.clinjournal.org/clinj/article/view/110) &lt;br>
      > *Computational Linguistics in the Netherlands Journal*, 10, pages 129--145. &lt;br>

      Voor AlpinoGraph zijn al de SPOD-query's herschreven in Cypher. De
      resultaten die je krijgt met deze nieuwe versies zijn niet altijd gelijk aan
      de resultaten die je kreeg in PaQu, voornamelijk vanwege de technische
      beperkingen van de oorspronkelijke query's in XPath. Zie paper:
      > Peter Kleiweg and Gertjan van Noord. 2020. &lt;br>
      > [AlpinoGraph: A Graph-based search engine for flexible and efficient treebank search.](https://www.aclweb.org/anthology/2020.tlt-1.13/)  &lt;br>
      > In *Proceedings of the 19th International Workshop on Treebanks and Linguistic Theories*,
      > pages 151--161, Düsseldorf, Germany, 27--28 October. Association for Computational Linguistics.  &lt;br>
    </item>

    <item id="spod-attrib" lbl="Attributen">
      <item id="spod-pos" lbl="pos">
        match (w:word)
        return w.pos as pos, count(*) as aantal
        order by pos
      </item>
      <item id="spod-postag" lbl="postag">
        match (w:word)
        return w.postag as postag, count(*) as aantal
        order by postag
      </item>
      <item id="spod-pt" lbl="pt">
        match (w:word)
        return w.pt as pt, count(*) as aantal
        order by pt
      </item>
    </item>

    <item id="spod-sents" lbl="Hoofdzinnen">
      <item id="spod-sents-info" lbl="Info" class="info">
        Bij deze queries vergelijken we de verschillende typen hoofdzinnen:
        mededelende hoofdzinnen (1), vraagzinnen die met een vraag-constituent
        beginnen (2), ja/nee vragen (3), en imperatieven (4).

        |      |    |
        | ---: | -- |
        | (1)  |  Pieter leest een boek. |
        |      | &amp;nbsp; |
        | (2)  | Wie leest er een boek? |
        |      | &amp;nbsp; |
        | (3)  | Lees jij een boek? |
        |      | &amp;nbsp; |
        | (4a) | Lees dat boek nou toch eens. |
        |   b) | Lees jij dat boek nou toch eens. |

        Het onderscheid tussen ja/nee vragen en imperatieven is in de
        treebanks niet altijd nauwkeurig te bepalen --- met name voor
        de handmatig geannoteerde treebanks die iets minder informatie
        bevatten dan de automatisch geannoteerde treebanks. Bijvoorbeeld
        imperatieven die wel een onderwerp bevatten (4b) zullen door de
        bestaande queries niet worden gevonden als imperatief.
      </item>
      <item id="spod-smain" lbl="mededelende hoofdzinnen">
        <item id="spod-smain-zin" lbl="zinnen">
          match p = (:node{cat: 'smain'})
          return p
        </item>
        <item id="spod-smain-tel" lbl="telling">
          match (n:node{cat: 'smain'})
          with n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-whq" lbl="vraagzinnen (wh)">
        <item id="spod-whq-zin" lbl="zinnen">
          match p = (:node{cat: 'whq'})
          return p
        </item>
        <item id="spod-whq-tel" lbl="telling">
          match (n:node{cat: 'whq'})
          with n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-janee" lbl="ja/nee vragen">
        <item id="spod-janee-zin" lbl="zinnen">
          match (w:word{word: '?'}) ,
                (n:node{sentid:w.sentid,cat: 'sv1'})&lt;-[r:rel]-()
          optional match (n)-[:rel{rel: 'hd'}]->(n1)
          with w, r, n, n1
          where not r.rel = 'body'
            and n.end &lt; w.end
            and (n1 is null or n1.stype is null or n1.stype = 'ynquestion')
          return n.sentid, n.id
        </item>
        <item id="spod-janee-tel" lbl="telling">
          match (w:word{word: '?'}) ,
                (n:node{sentid:w.sentid,cat: 'sv1'})&lt;-[r:rel]-()
          optional match (n)-[:rel{rel: 'hd'}]->(n1)
          with w, r, n, n1
          where not r.rel = 'body'
            and n.end &lt; w.end
            and (n1 is null or n1.stype is null or n1.stype = 'ynquestion')
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-imp" lbl="imperatieven">
        <item id="spod-imp-zin" lbl="zinnen">
          match (n:node{cat: 'sv1'})
            optional match (n)-[:rel{rel: 'su'}]->(x1)
            optional match (n)-[:rel{rel: 'hd'}]->(x2)
          with n, x1, x2
          where x1 is null
            and not (x2.stype        is not null and not x2.stype = 'imparative')
            and not ((x2.tense        is not null and x2.tense = 'past') or
                     (x2.pvagr        is not null and x2.pvagr in ['mv','met-t']) or
                     (x2.pvtijd is not null and x2.pvtijd = 'verl') or
                     (x2.lemma        is not null and x2.lemma in ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben']) )
          return n.sentid, n.id
        </item>
        <item id="spod-imp-tel" lbl="telling">
          match (n:node{cat: 'sv1'})
            optional match (n)-[:rel{rel: 'su'}]->(x1)
            optional match (n)-[:rel{rel: 'hd'}]->(x2)
          with n, x1, x2
          where x1 is null
            and not (x2.stype          is not null and not x2.stype = 'imparative')
            and not ((x2.tense  is not null and x2.tense = 'past') or
                     (x2.pvagr  is not null and x2.pvagr in ['mv','met-t']) or
                     (x2.pvtijd is not null and x2.pvtijd = 'verl') or
                     (x2.lemma  is not null and x2.lemma in ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben']) )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
    </item>

    <item id="spod-bijzinnen" lbl="Bijzinnen">

      <item id="spod-bijzinnen-info" lbl="Info" class="info">
        Deze queries vergelijken de verschillende soorten bijzinnen.
        We onderscheiden de volgende bijzinnen: ingebedde vraagzinnen
        met een vraag-constituent (1), finiete bijzinnen (2), infiniete
        bijzinnen met *om te* (3) infiniete bijzinnen met alleen *te* (4),
        en infiniete bijzinnen met een ander voorzetsel (5). Daarnaast
        onderscheiden we relatieve bijzinnen (6) en free relatives (7).

        |      |    |
        | ---: | -- |
        | (1)  | (ik vroeg) wie dat boek gelezen heeft |
        |      | &amp;nbsp; |
        | (2a) | (ik lees dat boek) omdat het door Elsschot geschreven is |
        |   b) | (ik denk) dat het boek door Elsschot is geschreven |
        |   c) | (ik vroeg) of het boek door Ellschot is geschreven |
        |      | &amp;nbsp; |
        | (3a) | (ik heb geprobeerd) om een boek te lezen |
        |   b) | (ik ga naar de bieb) om een boek te lezen |
        |   c) | (het was niet nodig) om het boek te lezen |
        |   d) | (slangen zijn) om van te gruwen |
        |   e) | (het kind is oud genoeg) om alleen naar school te gaan |
        |   f) | (het boek is te duur) om te kopen |
        |   g) | (hij heeft voldoende invloed) om het boek te verkopen |
        |   h) | (ze was zo genadig) om het boek voor te lezen |
        |   i) | (een boek) om nooit te vergeten |
        |      | &amp;nbsp; |
        | (4)  | (ik heb geprobeerd) een boek te lezen |
        |      | &amp;nbsp; |
        | (5)  | (ik lees dat boek) zonder mijn oordeel uit te spreken |
        |      | &amp;nbsp; |
        | (6)  | (ik lees een boek) dat door Elsschot is geschreven |
        |      | &amp;nbsp; |
        | (7)  | wie dit leest (is gek) |

        Binnen de finiete bijzinnen maken we onderscheid tussen bijzinnen die
        ingeleid worden met *dat* (2b), met *of* (2c) dan wel met een ander
        voegwoord (2a).

        De infiniete bijzinnen met *om* worden verder onderverdeeld naar
        gelang de bijzin optreedt als complement (3a), of als bepaling (3b),
        als onderwerp (3c), als predicatief complement (3d), of als
        comperatief complement (3efgh). Infiniete bijzinnen die als
        bepaling optreden worden verder onderverdeeld, afhankelijk of
        de bepaling bij een werkwoord optreedt (3b) of bij een zelfstandig
        naamwoord (3i).
      </item>

      <item id="spod-whsub" lbl="ingebedde vraagzinnen">
        <item id="spod-whsub-zin" lbl="zinnen">
          match (n:node{cat: 'whsub'})-[:rel*1..2]->(n2:node{cat: 'ssub'})
          where exists ((n)-[:rel{rel: 'body'}]->(n2))
             or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->(n2))
             or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'du'})-[:rel]->(n2))
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-whsub-tel" lbl="telling">
          match (n:node{cat: 'whsub'})-[:rel*1..2]->(n2:node{cat: 'ssub'})
          where exists ((n)-[:rel{rel: 'body'}]->(n2))
             or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->(n2))
             or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'du'})-[:rel]->(n2))
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ssub" lbl="finiete bijzinnen">
        <item id="spod-ssub-zin" lbl="zinnen">
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-ssub-tel" lbl="telling">
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ssubdat" lbl="finiete bijzinnen met &quot;dat&quot;">
        <item id="spod-ssubdat-zin" lbl="zinnen">
          match (n1:word{lemma: 'dat'})&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, n1.id, n2.id
        </item>
        <item id="spod-ssubdat-tel" lbl="telling">
          match (:word{lemma: 'dat'})&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ssubof" lbl="finiete bijzinnen met &quot;of&quot;">
        <item id="spod-ssubof-zin" lbl="zinnen">
          match (w:word{lemma: 'of'})&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, w.id, n2.id
        </item>
        <item id="spod-ssubof-tel" lbl="telling">
          match (:word{lemma: 'of'})&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ssubcmp" lbl="finiete bijzinnen met andere voegwoorden">
        <item id="spod-ssubcmp-zin" lbl="zinnen">
          match (w:nw)&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          where not (w.lemma is not null and w.lemma in ['of','dat'])
          return n.sentid, n.id, w.id, n2.id
        </item>
        <item id="spod-ssubcmp-tel" lbl="telling">
          match (w:nw)&lt;-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          where not (w.lemma is not null and w.lemma in ['of','dat'])
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-oti" lbl="infiniete bijzinnen met &quot;om&quot;">
        <item id="spod-oti-zin" lbl="zinnen">
          match p = (:node{cat: 'oti'})
          return p
        </item>
        <item id="spod-oti-tel" lbl="telling">
          match (n:node{cat: 'oti'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-otivc" lbl="infiniete bijzinnen met &quot;om&quot; die als complement optreden">
        <item id="spod-otivc-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'vc'}]-(n2:node)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otivc-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'vc'}]-(:node)
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-otimod" lbl="infiniete bijzinnen met &quot;om&quot; die als bepaling optreden">
        <item id="spod-otimod-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'mod'}]-(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otimod-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'mod'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-otiww" lbl="infiniete bijzinnen met &quot;om&quot; die als bepaling bij een werkwoord optreden">
        <item id="spod-otiww-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-otiww-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(:word{pt: 'ww'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-otin" lbl="infiniete bijzinnen met &quot;om&quot; die als bepaling bij een zelfstandig naamwoord optreden">
        <item id="spod-otin-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word)
          where w.pt in ['n','vnw']
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-otin-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word)
          where w.pt in ['n','vnw']
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-otisu" lbl="infiniete bijzinnen met &quot;om&quot; die als onderwerp fungeren">
        <item id="spod-otisu-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'su'}]-(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otisu-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'su'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-otipred" lbl="infiniete bijzinnen met &quot;om&quot; die als predicaat fungeren">
        <item id="spod-otipred-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'predc'}]-(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otipred-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'predc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-otiobc" lbl="infiniete bijzinnen met &quot;om&quot; die optreden met combinaties zoals &quot;te ADJ; zo ADJ; genoeg ADJ; voldoende N&quot;">
        <item id="spod-otiobc-zin" lbl="zinnen">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'obcomp'}]-(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-otiobc-tel" lbl="telling">
          match (n:node{cat: 'oti'})&lt;-[:rel{rel: 'obcomp'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-tite" lbl="infiniete bijzinnen met alleen &quot;te&quot;">
        <item id="spod-tite-zin" lbl="zinnen">
          match (n:node{cat: 'ti'})&lt;-[:rel]-(n2:node)
          where not n2.cat in ['oti','cp']
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-tite-tel" lbl="telling">
          match (n:node{cat: 'ti'})&lt;-[:rel]-(n2:node)
          where not n2.cat in ['oti','cp']
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ti" lbl="infiniete bijzinnen met ander voorzetsel">
        <item id="spod-ti-zin" lbl="zinnen">
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ti'})
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-ti-tel" lbl="telling">
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ti'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-relssub" lbl="relatieve bijzinnen">
        <item id="spod-relssub-zin" lbl="zinnen">
          match (n:node{cat: 'rel'})-[:rel{rel: 'body'}]->(n1:node)-[r:rel*0..1]->(n2:node{cat: 'ssub'})
          where length(r) = 0
             or n1.cat = 'conj' and r[0].rel = 'cnj'
             or n1.cat = 'du'
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-relssub-tel" lbl="telling">
          match (n:node{cat: 'rel'})-[:rel{rel: 'body'}]->(n1:node)-[r:rel*0..1]->(n2:node{cat: 'ssub'})
          where length(r) = 0
             or n1.cat = 'conj' and r[0].rel = 'cnj'
             or n1.cat = 'du'
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-whrel" lbl="free relatives">
        <item id="spod-whrel-zin" lbl="zinnen">
          match (n:node{cat: 'whrel'})-[:rel{rel: 'body'}]->(n2:node)
          where not exists( (:node)-[:rel{rel: 'mod'}]->(n) )
            and (n2.cat = 'ssub'
                 or n2.cat = 'conj' and exists( (n2)-[:rel{rel: 'cnj'}]->(:node{cat: 'ssub'}) )
                 or n2.cat = 'du' and exists( (n2)-[:rel]->(:node{cat: 'ssub'}) ) )
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-whrel-tel" lbl="telling">
          match (n:node{cat: 'whrel'})-[:rel{rel: 'body'}]->(n2:node)
          where not exists( (:node)-[:rel{rel: 'mod'}]->(n) )
            and (n2.cat = 'ssub'
                 or n2.cat = 'conj' and exists( (n2)-[:rel{rel: 'cnj'}]->(:node{cat: 'ssub'}) )
                 or n2.cat = 'du' and exists( (n2)-[:rel]->(:node{cat: 'ssub'}) ) )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
    </item>

    <item id="spod-corc" lbl="Correlatieve comparatieven">
      <item id="spod-corc-info" lbl="Info" class="info">
        Correlatieve comparatieven zijn zinnen zoals:

        |     |    |
        | --: | -- |
        | (1) | Hoe langer, hoe beter |
        |     | &amp;nbsp; |
        | (2) | Hoe langer hij wordt, des te meer hij last van zijn rug krijgt |
      </item>
      <item id="spod-corc-zin" lbl="zinnen">
        match p1 = (n1:node{_deste: true})&lt;-[:rel*0..]-(n0:node)&lt;-[:rel*0..]-(n:node{cat: 'du'})
        match p2 = (n1)&lt;-[:rel*0..]-(n0)-[:rel*0..]->(n2:node{_deste: true})
        optional match p = (n0)&lt;-[:rel*0..]-(:node{cat:'du'})&lt;-[:rel*1..]-(n)
        with n1, n2, p, p1, p2
        where n1.id &lt; n2.id
          and p is null
        return p1, p2
      </item>
      <item id="spod-corc-tel" lbl="telling">
        match (n1:node{_deste: true})&lt;-[:rel*0..]-(n0:node)&lt;-[:rel*0..]-(n:node{cat: 'du'})
        match (n1)&lt;-[:rel*0..]-(n0)-[:rel*0..]->(n2:node{_deste: true})
        optional match p = (n0)&lt;-[:rel*0..]-(:node{cat:'du'})&lt;-[:rel*1..]-(n)
        with n, n1, n2, p
        where n1.id &lt; n2.id
          and p is null
        with distinct n.sentid as sentid, n.id as id
        return count(distinct(sentid)) as zinnen, count(*) as items
      </item>
    </item>

    <item id="spod-compcomp" lbl="Woorden met een comparatief complement">
      <item id="spod-compcomp-info" lbl="Info" class="info">
        Comparatieve adjectieven en woorden zo als *zo*, *even*, *meer*,
        *minder*, *niet*, *niets*, *ander*, *anders* treden soms op met
        een complement dat vaak wordt ingeleid met het woord *dan* of *als*.
        Naast het totale aantal voorkomens van de constructie kijken we naar
        het aantal voorbeelden waarbij *zo* (1) of *even* (2) of een
        comparatief adjective (3) of *meer* of *minder* (4) of *niet*,
        *niets*, *ander*, *anders* (5) het hoofd is.

        Bij comparatieve adjectieven make we ook nog een onderverdeling
        naar de aard van het complement. Een vergelijkbare onderverdeling
        wordt gemaakt voor de andere hoofden.

        |      |    |
        | ---: | -- |
        | (1)  | zo groen als gras |
        |      | &amp;nbsp; |
        | (2)  | even dik als jij |
        |      | &amp;nbsp; |
        | (3a) | beter dan jij |
        |   b) | beter dan ik dacht |
        |   c) | beter dan bij de buren |
        |   d) | beter dan gisteren |
        |      |  &amp;nbsp; |
        | (4a) | meer geluk dan wijsheid |
        |   b) | meer geluk dan ik dacht |
        |   c) | meer geluk dan bij de buren |
        |   d) | meer geluk dan gisteren |
        |      |  &amp;nbsp; |
        | (5a) | niets anders dan ellende |
        |   b) | niets anders dan dat hij komt |
        |   c) | niets anders dan bij de buren |
        |   d) | niets anders dan gisteren |
      </item>
      <item id="spod-cc" lbl="totaal">
        <item id="spod-cc-zin" lbl="zinnen">
          match (n:nw)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-cc-tel" lbl="telling">
          match (n:nw)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cczo" lbl="met als hoofd &quot;zo&quot;">
        <item id="spod-cczo-zin" lbl="zinnen">
          match (w:word{lemma: 'zo'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-cczo-tel" lbl="telling">
          match (w:word{lemma: 'zo'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cceven" lbl="met als hoofd &quot;even&quot;">
        <item id="spod-cceven-zin" lbl="zinnen">
          match (w:word{lemma: 'even'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return distinct w.sentid, w.id, n2.id
        </item>
        <item id="spod-cceven-tel" lbl="telling">
          match (w:word{lemma: 'even'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccca" lbl="met als hoofd comparatief adjectief">
        <item id="spod-ccca-zin" lbl="zinnen">
          match (n:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return n.sentid, n.id, n2.id
        </item>
        <item id="spod-ccca-tel" lbl="telling">
          match (n:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccdannp" lbl="met als hoofd comparatief adjectief, gevolgd door NP">
        <item id="spod-ccdannp-zin" lbl="zinnen">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)-[:rel{rel: 'body'}]->(x{_np:true})
          return w.sentid, w.id, n2.id, x.id
        </item>
        <item id="spod-ccdannp-tel" lbl="telling">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x{_np:true})
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccdanvs" lbl="met als hoofd comparatief adjectief, gevolgd door VP of S">
        <item id="spod-ccdanvs-zin" lbl="zinnen">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-(n2)-[:rel{rel: 'obcomp'}]->()-[:rel]->(x:nw)
          where (x.cat is not null and x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'])
             or (x.pt is not null and x.pt = 'ww')
          return distinct w.sentid, w.id, n2.id, x.id
        </item>
        <item id="spod-ccdanvs-tel" lbl="telling">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel]->(x:nw)
          where (x.cat is not null and x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'])
             or (x.pt is not null and x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccdanpp" lbl="met als hoofd comparatief adjectief, gevolgd door PP">
        <item id="spod-ccdanpp-zin" lbl="zinnen">
          match (w:word{pt: 'adj',graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-(:node)-[:rel{rel: 'obcomp'}]->(:node)-[:rel{rel: 'body'}]->(n2:node{cat: 'pp'})
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccdanpp-tel" lbl="telling">
          match (w:word{pt: 'adj',graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-(:node)-[:rel{rel: 'obcomp'}]->(:node)-[:rel{rel: 'body'}]->(:node{cat: 'pp'})
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccdanav" lbl="met als hoofd comparatief adjectief, gevolgd door A of ADV">
        <item id="spod-ccdanav-zin" lbl="zinnen">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where (x.cat is not null and x.cat in ['advp','ap'])
             or (x.pt is not null and x.pt in ['adj','bw'])
          return w.sentid, w.id, x.id
        </item>
        <item id="spod-ccdanav-tel" lbl="telling">
          match (w:word{pt: 'adj', graad: 'comp'})&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where (x.cat is not null and x.cat in ['advp','ap'])
             or (x.pt is not null and x.pt in ['adj','bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccmm" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;">
        <item id="spod-ccmm-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          where w.lemma in ['veel','minder','weinig']
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccmm-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          where w.lemma in ['veel','minder','weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccmdnp" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;, gevolgd door NP">
        <item id="spod-ccmdnp-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw{_np: true})
          where w.lemma in ['veel', 'minder', 'weinig']
          return w.sentid, w.id, x.id
        </item>
        <item id="spod-ccmdnp-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(:nw{_np: true})
          where w.lemma in ['veel', 'minder', 'weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccmdvs" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;, gevolgd door VP of S">
        <item id="spod-ccmdvs-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
            and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          return w.sentid, w.id, x.id
        </item>
        <item id="spod-ccmdvs-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
            and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccmdpp" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;, gevolgd door PP">
        <item id="spod-ccmdpp-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(n2:node{cat: 'pp'})
          where w.lemma in ['veel', 'minder', 'weinig']
          return distinct w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccmdpp-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(:node{cat: 'pp'})
          where w.lemma in ['veel', 'minder', 'weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccmdav" lbl="met als hoofd &quot;meer&quot;, &quot;minder&quot;, gevolgd door A of ADV">
        <item id="spod-ccmdav-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
            and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          return distinct w.sentid, w.id, x.id
        </item>
        <item id="spod-ccmdav-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
          and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccnn" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;">
        <item id="spod-ccnn-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccnn-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccndnp" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;, gevolgd door NP">
        <item id="spod-ccndnp-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(n2:nw{_np: true})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccndnp-tel" lbl="telling">
            match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(:nw{_np: true})
            where w.lemma in ['niet', 'niets', 'ander', 'anders']
            with distinct w.sentid as sentid, w.id as id
            return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccndvs" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;, gevolgd door VP of S">
        <item id="spod-ccndvs-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
            and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          return distinct w.sentid, w.id, x.id
        </item>
        <item id="spod-ccndvs-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
            and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccndpp" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;, gevolgd door PP">
        <item id="spod-ccndpp-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(n2:node{cat: 'pp'})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        </item>
        <item id="spod-ccndpp-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(:node{cat: 'pp'})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ccndav" lbl="met als hoofd &quot;niet&quot;, &quot;niets&quot;, &quot;ander&quot;, &quot;anders&quot;, gevolgd door A of ADV">
        <item id="spod-ccndav-zin" lbl="zinnen">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
            and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          return w.sentid, w.id, x.id
        </item>
        <item id="spod-ccndav-tel" lbl="telling">
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
            and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
    </item>

    <item id="spod-neven" lbl="Nevenschikkingen">
      <item id="spod-neven-info" lbl="Info" class="info">
        Bij nevenschikkingen maken we onderscheid naar gelang
        het aantal coordinatoren. Geen (1), één (2), twee (3) of meer (4).

        |      |  |
        | ---: | -- |
        | (1)  | Zij wilden inspraak , medezeggenschap , democratisering |
        |      | &amp;nbsp; |
        | (2a) | Appels en peren |
        |   b) | Appels of peren |
        |   c) | De afzijdige maar invloedrijke waarnemer |
        |   d) | Ze helpen eiwitten, vetten, etc. afbreken |
        |      | &amp;nbsp; |
        | (3)  | Noch appels noch peren |
        |      | &amp;nbsp; |
        | (4)  | U kunt gezond zijn, of ziek of arm of rijk |

        Indien er precies één coordinator is, maken we onderscheid tussen
        *en* (2a), *of* (2b), *maar* (2c) en het speciale geval waar de
        conjunctie wordt afgesloten met een woord zoals *enzovoorts* dat
        in de annotatie ook als coordinator wordt weergegeven (2d).

        We maken ook een onderverdeling naar gelang het aantal conjuncten
        dat in de coordinatie optreedt. Eén (5), twee (2), drie (6), vier,
        vijf, zes, of meer.

        |      |    |
        | ---: | -- |
        | (5)  | de milieuverontreiniging, enzovoorts |
        |      | &amp;nbsp; |
        | (6)  | cacaoboter , cacaopoeder of palmolie |

        Ten slotte wordt een onderscheid gemaakt naar de categorie van de
        conjuncten: NP (2), PP (7), hoofdzinnen (8), VP (9) en bijzinnen (10).

        |      |    |
        | ---: | -- |
        | (7)  | in Arnhem en in België |
        |      | &amp;nbsp; |
        | (8)  | Drie keer hadden ze dat beloofd en drie keer was die belofte weer ingetrokken |
        |      | &amp;nbsp; |
        | (9)  | die sinds 1981 in Duitsland woont en werkt |
        |      |  &amp;nbsp; |
        | (10) | (Hij zei) dat het er bij hoorde, en dat ik niet bang hoefde te zijn |
      </item>
      <item id="spod-conj" lbl="alle nevenschikkingen">
        <item id="spod-conj-zin" lbl="zinnen">
          match p = (:node{cat: 'conj'})
          return p
        </item>
        <item id="spod-conj-tel" lbl="telling">
          match (n:node{cat: 'conj'})
          return count(distinct(n.sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crdcount" lbl="nevenschikkingen met aantal coördinatoren (minimaal 1)">
        select crd, count(*) as aantal
        from (
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as crd
          return crd
        ) as foo
        group by crd
        order by crd
      </item>
      <item id="spod-crd0" lbl="nevenschikkingen zonder coördinator">
        <item id="spod-crd0-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})
          optional match (n)-[r:rel{rel: 'crd'}]->()
          with n, r
          where r is null
          return n.sentid, n.id
        </item>
        <item id="spod-crd0-tel" lbl="telling">
          match (n:node{cat: 'conj'})
          optional match (n)-[r:rel{rel: 'crd'}]->()
          with n, r
          where r is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crd1" lbl="nevenschikkingen met 1 coördinator">
        <item id="spod-crd1-zin" lbl="zinnen">
          match p = (:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with p, count(*) as cnt
          where cnt = 1
          return p
        </item>
        <item id="spod-crd1-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt = 1
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crd1en" lbl="nevenschikkingen met 1 coördinator, en dat is &quot;en&quot;">
        <item id="spod-crd1en-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'en'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-crd1en-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'en'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crd1of" lbl="nevenschikkingen met 1 coördinator, en dat is &quot;of&quot;">
        <item id="spod-crd1of-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'of'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-crd1of-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'of'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crd1maa" lbl="nevenschikkingen met 1 coördinator, en dat is &quot;maar&quot;">
        <item id="spod-crd1maa-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'maar'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        </item>
        <item id="spod-crd1maa-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'maar'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crd1enz" lbl="nevenschikkingen met 1 coördinator, en de coordinator sluit de nevenschikking af (&quot;enzovoorts&quot;)">
        <item id="spod-crd1enz-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(x:nw)
          with n, x, count(*) as cnt
          where cnt = 1 and x.end = n.end
          return n.sentid, n.id, x.id
        </item>
        <item id="spod-crd1enz-tel" lbl="telling">
            match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
            optional match (n)-[:rel{rel: 'crd'}]->(x:nw)
            with n, x, count(*) as cnt
            where cnt = 1 and x.end = n.end
            with distinct n.sentid as sentid, n.id as id
            return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crd2" lbl="nevenschikkingen met 2 coördinatoren">
        <item id="spod-crd2-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt = 2
          return n.sentid, n.id
        </item>
        <item id="spod-crd2-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt = 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crd2p" lbl="nevenschikkingen met meer dan 2 coördinatoren">
        <item id="spod-crd2p-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt > 2
          return n.sentid, n.id
        </item>
        <item id="spod-crd2p-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt > 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-crd22" lbl="reeksvormers (nevenschikkingen van de vorm crd,cnj,crd,cnj...)">
        <item id="spod-crd22-zin" lbl="zinnen">
          -- Dit werkt niet optimaal. Sommige reeksen worden niet gevonden.

          match (n1:nw)&lt;-[:rel{rel:'crd'}]-(n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->(n3:nw)
          match (n2:nw{sentid: n.sentid})&lt;-[:rel{rel:'cnj'}]-(n)-[:rel{rel: 'cnj'}]->(n4:nw)
          where n1.id = n.id + 1
          and (
                n1.id &lt; n2.id
            and n2.id &lt; n3.id
            and n3.id &lt; n4.id
            or
                n1.begin &lt; n2.begin
            and n2.begin &lt; n3.begin
            and n3.begin &lt; n4.begin
          )
          return n
        </item>
        <item id="spod-crd22-tel" lbl="telling">
          -- Dit werkt niet optimaal. Sommige reeksen worden niet gevonden.

          match (n1:nw)&lt;-[:rel{rel:'crd'}]-(n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->(n3:nw)
          match (n2:nw{sentid: n.sentid})&lt;-[:rel{rel:'cnj'}]-(n)-[:rel{rel: 'cnj'}]->(n4:nw)
          where n1.id = n.id + 1
          and (
                n1.id &lt; n2.id
            and n2.id &lt; n3.id
            and n3.id &lt; n4.id
            or
                n1.begin &lt; n2.begin
            and n2.begin &lt; n3.begin
            and n3.begin &lt; n4.begin
          )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cnjcount" lbl="nevenschikkingen met aantal conjuncten (minimaal 1)">
        select cnj, count(*) as aantal
        from (
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnj
          return cnj
        ) as foo
        group by cnj
        order by cnj
      </item>
      <item id="spod-cnj1" lbl="nevenschikkingen met slechts 1 conjunct">
        <item id="spod-cnj1-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 1
          return n.sentid, n.id
        </item>
        <item id="spod-cnj1-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 1
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cnj2" lbl="nevenschikkingen met 2 conjuncten">
        <item id="spod-cnj2-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 2
          return n.sentid, n.id
        </item>
        <item id="spod-cnj2-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cnj3" lbl="nevenschikkingen met 3 conjuncten">
        <item id="spod-cnj3-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 3
          return n.sentid, n.id
        </item>
        <item id="spod-cnj3-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 3
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cnj4" lbl="nevenschikkingen met 4 conjuncten">
        <item id="spod-cnj4-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 4
          return n.sentid, n.id
        </item>
        <item id="spod-cnj4-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 4
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cnj5" lbl="nevenschikkingen met 5 conjuncten">
        <item id="spod-cnj5-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 5
          return n.sentid, n.id
        </item>
        <item id="spod-cnj5-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 5
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cnj6" lbl="nevenschikkingen met 6 conjuncten">
        <item id="spod-cnj6-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 6
          return n.sentid, n.id
        </item>
        <item id="spod-cnj6-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 6
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cnj6p" lbl="nevenschikkingen met meer dan 6 conjuncten">
        <item id="spod-cnj6p-zin" lbl="zinnen">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt > 6
          return n.sentid, n.id
        </item>
        <item id="spod-cnj6p-tel" lbl="telling">
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt > 6
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-cnjnp" lbl="nevenschikking van NP's">
        <item id="spod-cnjnp-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{_np: true})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2._np is null
          return n.sentid, n.id
        </item>
        <item id="spod-cnjnp-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{_np: true})
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where n2._np is null
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-cnjpp" lbl="nevenschikking van PP's">
        <item id="spod-cnjpp-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'pp'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'pp'
          return n.sentid, n.id
        </item>
        <item id="spod-cnjpp-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
           match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'pp'})
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where n2.cat is null or n2.cat != 'pp'
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-cnjmain" lbl="nevenschikking van hoofdzinnen">
        <item id="spod-cnjmain-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'smain'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'smain'
          return n.sentid, n.id
        </item>
        <item id="spod-cnjmain-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'smain'})
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where n2.cat is null or n2.cat != 'smain'
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-cnjvp" lbl="nevenschikking van VP">
        <item id="spod-cnjvp-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n1:nw)
          where n1.cat in ['ssub','ti','ppart','inf']
             or n1.pt = 'ww'
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where not ( n2.cat is not null and n2.cat in ['ssub','ti','ppart','inf']
             or n2.pt is not null and n2.pt = 'ww' )
          return n.sentid, n.id
        </item>
        <item id="spod-cnjvp-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n1:nw)
            where n1.cat in ['ssub','ti','ppart','inf']
               or n1.pt = 'ww'
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where not ( n2.cat is not null and n2.cat in ['ssub','ti','ppart','inf']
               or n2.pt is not null and n2.pt = 'ww' )
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-cnjcp" lbl="nevenschikking van bijzinnen">
        <item id="spod-cnjcp-zin" lbl="zinnen">
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'cp'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'cp'
          return n.sentid, n.id
        </item>
        <item id="spod-cnjcp-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'cp'})
            return n.sentid, n.id
            except
            match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
            where n2.cat is null or n2.cat != 'cp'
            return n.sentid, n.id
          ) as foo
        </item>
      </item>
    </item>

    <item id="spod-wgroep" lbl="Woordgroepen">
      <item id="spod-wgroep-info" lbl="Info" class="info">
        Voor woordgroepen onderscheiden we hier naamwoordgroepen (1),
        voorzetselgroepen (2), bijvoeglijk-naamwoordgroepen (3) en
        bijwoordgroepen (4).

        |      |    |
        | ---: | -- |
        | (1)  | een grote boom |
        |      | &amp;nbsp; |
        | (2)  | op een tak |
        |      | &amp;nbsp; |
        | (3)  | heel erg geliefd |
        |      | &amp;nbsp; |
        | (4)  | spelenderwijs |
      </item>
      <item id="spod-np" lbl="np">
        <item id="spod-np-zin" lbl="zinnen">
          match (x:nw{_np: true})
          return x.sentid, x.id
        </item>
        <item id="spod-np-tel" lbl="telling">
          match (x:nw{_np: true})
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-pp" lbl="pp">
        <item id="spod-pp-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})
          return n.sentid, n.id
        </item>
        <item id="spod-pp-tel" lbl="telling">
          match (n:node{cat: 'pp'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ap" lbl="ap">
        <item id="spod-ap-zin" lbl="zinnen">
          match (x:nw)&lt;-[r:rel]-()
          where (x.cat is not null and x.cat = 'ap')
             or (x.pt is not null and x.pt = 'adj')
            and r.rel != 'hd'
          return x.sentid, x.id
        </item>
        <item id="spod-ap-tel" lbl="telling">
          match (x:nw)&lt;-[r:rel]-()
          where (x.cat is not null and x.cat = 'ap')
             or (x.pt is not null and x.pt = 'adj')
            and r.rel != 'hd'
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-advp" lbl="advp">
        <item id="spod-advp-zin" lbl="zinnen">
          match (x:nw)&lt;-[r:rel]-()
          where (x.cat is not null and x.cat = 'advp')
             or (x.pt is not null and x.pt = 'bw')
            and r.rel != 'hd'
          return x.sentid, x.id
        </item>
        <item id="spod-advp-tel" lbl="telling">
          match (x:nw)&lt;-[r:rel]-()
          where (x.cat is not null and x.cat = 'advp')
             or (x.pt is not null and x.pt = 'bw')
            and r.rel != 'hd'
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>

    </item>

    <item id="spod-ppgroep" lbl="Voorzetselgroepen">
      <item id="spod-ppgroep-info" lbl="Info" class="info">
        Voorzetselgroepen worden onderscheiden naar grammaticale
        functie en naar interne structuur. Voorzetselgroepen kunnen
        optreden als bepaling bij nomina (1), adjectieven (2) of
        bij werkwoorden (6). Dit laatste geval wordt in de traditionele
        grammatica een bijwoordelijke bepaling genoemd. Voorzetselgroepen
        kunnen ook als complement optreden. Hier onderscheiden we
        voorzetselvoorwerpen (3), locatief/directinele complementen (4)
        en predicatieve complementen (5).

        |      |    |
        | ---: | -- |
        | (1)  | De vrouw van de buurman |
        |      | &amp;nbsp; |
        | (2a) | De door hem beschreven voorvallen |
        |   b) | De op zichzelf rationele beslissingen |
        |      | &amp;nbsp; |
        | (3)  | We rekenen op zijn steun |
        |      | &amp;nbsp; |
        | (4a) | De ketchup vindt u bij de groenteafdeling |
        |   b) | We rijden wel even naar het station |
        |      | &amp;nbsp; |
        | (5a) | Die aanpak is niet zonder risico |
        |   b) | Je moet in het bezit zijn van een visum |
        |   c) | De haven is van cruciale betekenis |
        |      | &amp;nbsp; |
        | (6)  | We gaan vissen bij de brug |

        Voorzetselgroepen worden onderverdeeld aan de hand van hun
        interne structuur. We onderscheiden de meest gangbare structuur
        waarbij een voorzetsel direct gevolgd wordt door een NP (7) en
        de structuur waarbij een R-pronomen direct of indirect gevolgd
        wordt door het bijbehorende voorzetsel (8). Ten slotte volgt
        een aparte telling voor het aantal voorzetseluitdrukkingen.
        Dit zijn versteende combinaties zoals *ten tijde van*,
        *door middel van*, *naar aanleiding van* die zich als
        voorzetsel gedragen.

        |      |    |
        | ---: | -- |
        | (7)  | in de kooi |
        |      | &amp;nbsp; |
        | (8)  | Hij houdt daar helemaal niet van |
      </item>
      <item id="spod-ppnp" lbl="grammaticale functie, bepalingen bij zelfstandige naamwoorden">
        <item id="spod-ppnp-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(:node{cat: 'np'})
          return n.sentid, n.id
        </item>
        <item id="spod-ppnp-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(:node{cat: 'np'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ppap" lbl="grammaticale functie, bepalingen bij adjectieven (en als adjectief gebruikte deelwoorden)">
        <item id="spod-ppap-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n2:node{cat:'ap'})
          return n.sentid, n.id
          union
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n2:node)
          where n2.cat in ['ppart','ppres']
            and not exists((n2)&lt;-[:rel{rel: 'vc'}]-())
            and not exists((n2)&lt;-[:rel{rel: 'cnj'}]-()&lt;-[:rel{rel: 'vc'}]-())
          return n.sentid, n.id
        </item>
        <item id="spod-ppap-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n2:node{cat:'ap'})
            return distinct n.sentid, n.id
            union
            match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n2:node)
            where n2.cat in ['ppart','ppres']
              and not exists((n2)&lt;-[:rel{rel: 'vc'}]-())
              and not exists((n2)&lt;-[:rel{rel: 'cnj'}]-()&lt;-[:rel{rel: 'vc'}]-())
            return distinct n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-pppc" lbl="grammaticale functie, voorzetselvoorwerp">
        <item id="spod-pppc-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'pc'}]-()
          return n.sentid, n.id
        </item>
        <item id="spod-pppc-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'pc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ppld" lbl="grammaticale functie, locatief/directioneel complement">
        <item id="spod-ppld-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'ld'}]-()
          return n.sentid, n.id
        </item>
        <item id="spod-ppld-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'ld'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-pppredc" lbl="grammaticale functie, predicatief complement">
        <item id="spod-pppredc-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'predc'}]-()
          return n.sentid, n.id
        </item>
        <item id="spod-pppredc-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'predc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ppbep" lbl="grammaticale functie, bijwoordelijke bepaling">
        <item id="spod-ppbep-zin" lbl="zinnen">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n1)&lt;-[r:rel]-(n2)
          where n1.cat in ['smain','sv1','whq','ssub','inf']
             or (
               n1.cat = 'ppart'
               and (
                 r.rel = 'vc'
                 or (
                   r.rel = 'cnj'
                   and exists((n2)&lt;-[:rel{rel: 'vc'}]-())
                )
              )
            )
          return n.sentid, n.id
        </item>
        <item id="spod-ppbep-tel" lbl="telling">
          match (n:node{cat: 'pp'})&lt;-[:rel{rel: 'mod'}]-(n1)&lt;-[r:rel]-(n2)
          where n1.cat in ['smain','sv1','whq','ssub','inf']
             or (
               n1.cat = 'ppart'
               and (
                 r.rel = 'vc'
                 or (
                   r.rel = 'cnj'
                   and exists((n2)&lt;-[:rel{rel: 'vc'}]-())
                )
              )
            )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ppinp" lbl="interne structuur, P + NP">
        <item id="spod-ppinp-zin" lbl="zinnen">
          match (n1)&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(n2)
          where n1.begin = n.begin and n2.end = n.end
          return n.sentid, n.id
        </item>
        <item id="spod-ppinp-tel" lbl="telling">
          match (n1)&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(n2)
          where n1.begin = n.begin and n2.end = n.end
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ppirp" lbl="interne structuur, +R-pronomen + P">
        <item id="spod-ppirp-zin" lbl="zinnen">
          match (n1)&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(w:word{pt: 'vnw'})
          where w.begin = n.begin and n1.end = n.end
          return n.sentid, n.id
        </item>
        <item id="spod-ppirp-tel" lbl="telling">
          match (n1)&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(w:word{pt: 'vnw'})
          where w.begin = n.begin and n1.end = n.end
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-ppimwu" lbl="interne structuur, complex voorzetsel">
        <item id="spod-ppimwu-zin" lbl="zinnen">
          match (:node{cat: 'mwu'})&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})
          return n.sentid, n.id
        </item>
        <item id="spod-ppimwu-tel" lbl="telling">
          match (:node{cat: 'mwu'})&lt;-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
    </item>

    <item id="spod-ww" lbl="Werkwoorden">
      <item id="spod-ww-info" lbl="Info" class="info">
        Onder het kopje werkwoorden worden de vaste werkwoordelijke uitdrukkingen geteld (1).

        |      |    |
        | ---: | -- |
        | (1a) | aan bod komen |
        |   b) | ter kennis geven |
        |   c) | op prijs stellen |

        Daarnaast maken we een onderscheid bij werkwoordclusters tussen de zogenaamde
        rode en groene volgorde. Bij de groene werkwoordvolgorde gaat het voltooid
        deelwoord in de werkwoordcluster aan het hulpwerkwoord vooraf (2), en bij
        de rode volgorde volgt het voltooid deelwoord het hulpwerkwoord (3).

        |      |    |
        | ---: | -- |
        | (2a) | zijn boek zal morgen gepresenteerd worden |
        |   b) | ze zouden nooit een woord met elkaar gewisseld hebben |
        |      | &amp;nbsp; |
        | (3a) | zijn boek zal morgen worden gepresenteerd |
        |   b) | ze zouden nooit een woord met elkaar hebben gewisseld |

        Voorbeelden van werkwoordclusters worden gegeven in (2), (3), en (4).

        |      |    |
        | ---: | -- |
        | (4a) | Moet op korte termijn worden opgetreden? |
        |   b) | De zaak moet aanhangig worden gemaakt |
        |   c) | Ze zeiden dat ik dat zou hebben moeten kunnen zien aankomen |

        De "accusativus cum infinitivo" constructie vertoont de beroemde
        'cross-serial' afhankelijkheden. Voorbeelden zijn (5).
        Deze query werkt niet voor het CGN corpus.

        |      |    |
        | ---: | -- |
        | (5a) | Ik heb hem het boek zien lezen |
        |   b) | Ik heb hem de olifanten helpen voeren |
        |   c) | Ik heb hem de oppasser de olifanten zien helpen voeren |

        De passieve werkwoorden worden gebruikt in de lijdende vorm, als in (6).
        Het gaat hierbij om de gevallen waarbij een onderwerp aanwezig is.
        Deze query werkt niet voor het CGN corpus.

        |      |    |
        | ---: | -- |
        | (6a) | Hij wordt geslagen |
        |   b) | Het monument zal spoedig te zien zijn in het Amsterdamse Oosterpark |

        De niet-persoonlijke passieven identificeert de gevallen van de lijdende vorm
        waarbij geen echt onderwerp beschikbaar is. In die gevallen wordt vaak *er*
        als plaatsonderwerp gebruikt.

        |      |    |
        | ---: | -- |
        | (7a) | Er werd niet meer over gesproken |
        |   b) | In Amsterdam werd niet gedemonstreerd |
      </item>
      <item id="spod-vwuit" lbl="vaste werkwoordelijke uitdrukkingen">
        <item id="spod-vwuit-zin" lbl="zinnen">
          match (n:node)&lt;-[:rel{rel: 'svp'}]-()
          where n.cat is not null
          return n.sentid, n.id
        </item>
        <item id="spod-vwuit-tel" lbl="telling">
          match (n:node)&lt;-[:rel{rel: 'svp'}]-()
          where n.cat is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-groen" lbl="groene werkwoordsvolgorde">
        <item id="spod-groen-zin" lbl="zinnen">
          match (w:word{wvorm: 'vd'})&lt;-[:rel{rel: 'hd'}]-(:node)&lt;-[:rel{rel: 'vc'}]-(:node)-[:rel{rel: 'hd'}]->(x)
          where w.begin &lt; x.begin
            and not exists( (w)&lt;-[:rel*2]-(:node{sentid: w.sentid, cat: 'smain'}) )
            and not exists( (w)&lt;-[:rel*2]-(:node{sentid: w.sentid, cat: 'sv1'}) )
          return w.sentid, w.id
        </item>
        <item id="spod-groen-tel" lbl="telling">
          match (w:word{wvorm: 'vd'})&lt;-[:rel{rel: 'hd'}]-(:node)&lt;-[:rel{rel: 'vc'}]-(:node)-[:rel{rel: 'hd'}]->(x)
          where w.begin &lt; x.begin
            and not exists( (w)&lt;-[:rel*2]-(:node{sentid: w.sentid, cat: 'smain'}) )
            and not exists( (w)&lt;-[:rel*2]-(:node{sentid: w.sentid, cat: 'sv1'}) )
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-rood" lbl="rode werkwoordsvolgorde">
        <item id="spod-rood-zin" lbl="zinnen">
          match (n:word{wvorm: 'vd'})&lt;-[:rel{rel: 'hd'}]-()&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          optional match (n)&lt;-[:rel]-()&lt;-[:rel]-(n2:node{cat: 'smain'})
          optional match (n)&lt;-[:rel]-()&lt;-[:rel]-(n3:node{cat: 'sv1'})
          with n, n2, n3, w
          where n.begin > w.begin
            and n2 is null
            and n3 is null
          return n.sentid, n.id
        </item>
        <item id="spod-rood-tel" lbl="telling">
          match (n:word{wvorm: 'vd'})&lt;-[:rel{rel: 'hd'}]-()&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          optional match (n)&lt;-[:rel]-()&lt;-[:rel]-(n2:node{cat: 'smain'})
          optional match (n)&lt;-[:rel]-()&lt;-[:rel]-(n3:node{cat: 'sv1'})
          with n, n2, n3, w
          where n.begin > w.begin
            and n2 is null
            and n3 is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-wwclus" lbl="werkwoordsclusters">
        <item id="spod-wwclus-zin" lbl="zinnen">
          match (n1:nw)&lt;-[:rel]-(n:node)&lt;-[:rel{rel: 'vc'}]-(n0:node)-[:rel{rel: 'hd'}]->(n2:word{pt: 'ww'})
          where n.cat in ['ti','inf','ppart']
            and not(n0.cat in ['smain','sv1']) -- dit hoeft niet per se n0 te zijn???
            and n1.begin &lt; n2.begin
          return n.sentid, n.id
        </item>
        <item id="spod-wwclus-tel" lbl="telling">
          match (n1:nw)&lt;-[:rel]-(n:node)&lt;-[:rel{rel: 'vc'}]-(n0:node)-[:rel{rel: 'hd'}]->(n2:word{pt: 'ww'})
          where n.cat in ['ti','inf','ppart']
            and not(n0.cat in ['smain','sv1']) -- dit hoeft niet per se n0 te zijn???
            and n1.begin &lt; n2.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-accinf" lbl="accusativus cum infinitivo">
        <item id="spod-accinf-zin" lbl="zinnen">
          -- niet voor Corpus Gesproken Nederlands

          match (x)&lt;-[:rel]-(n:node{cat: 'inf'})&lt;-[:rel{rel: 'vc'}]-(n1)-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          match (n)-[:rel{rel: 'su'}]->()&lt;-[:rel{rel: 'obj1'}]-(n1)
          where not n1.cat in ['smain','sv1']
            and x.begin &lt; w.begin
          return n.sentid, n.id
        </item>
        <item id="spod-accinf-tel" lbl="telling">
          -- niet voor Corpus Gesproken Nederlands

          match (x)&lt;-[:rel]-(n:node{cat: 'inf'})&lt;-[:rel{rel: 'vc'}]-(n1)-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          match (n)-[:rel{rel: 'su'}]->()&lt;-[:rel{rel: 'obj1'}]-(n1)
          where not n1.cat in ['smain','sv1']
            and x.begin &lt; w.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-passive" lbl="passief">
        <item id="spod-passive-zin" lbl="zinnen">
          -- niet voor Corpus Gesproken Nederlands

          match (n1:nw)&lt;-[:rel{rel: 'obj1'}]-()&lt;-[r:rel*0..1]-(n:node)&lt;-[:rel{rel: 'vc'}]-()&lt;-[:rel]-(n0)
          match (n0)-[:rel{rel: 'su'}]->(n1)
          where (length(r) = 0 and n.cat = 'ppart' or length(r) = 1 and n.cat = 'ti')
          return n.sentid, n.id
        </item>
        <item id="spod-passive-tel" lbl="telling">
          -- niet voor Corpus Gesproken Nederlands

          match (n1:nw)&lt;-[:rel{rel: 'obj1'}]-()&lt;-[r:rel*0..1]-(n:node)&lt;-[:rel{rel: 'vc'}]-()&lt;-[:rel]-(n0)
          match (n0)-[:rel{rel: 'su'}]->(n1)
          where (length(r) = 0 and n.cat = 'ppart' or length(r) = 1 and n.cat = 'ti')
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-nppas" lbl="niet-persoonlijke passief">
        <item id="spod-nppas-zin" lbl="zinnen">
          -- niet voor Corpus Gesproken Nederlands

          match (n:nw)&lt;-[:rel{rel: 'vc'}]-()
          match (n)&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(n1)
          match (n)&lt;-[:rel]-(n2)
          optional match (pn:node{cat: 'sv1'})-[:rel]->(n)
          optional match (pn)-[:rel{rel: 'su'}]->(px1)
          optional match (pn)-[:rel{rel: 'hd'}]->(px2)
          with n, n1, n2, pn, px1, px2
          where (n1.sc in ['passive','te_passive']
            or (n1.pt = 'ww'
               and (
                 ( n.cat = 'ppart'
                   and not exists ((n)-[:rel{rel: 'obj1'}]->())
                   and not exists ((n)-[:rel{rel: 'su'}]->())
                   and not exists ((n)-[:rel{rel: 'vc'}]->())
                   and not exists ((n)-[:rel{rel: 'predc'}]->()) )
                 or ( n.cat = 'ti'
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'obj1'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'su'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'vc'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'predc'}]->()) )
               ))
            ) and (
            -- n2 is een parent van n
            not exists((n2)-[:rel{rel: 'su'}]->())
            and (
              n2.cat in ['smain','ssub']
              or (
                n2.cat = 'sv1'
                and not (
                  -- imperatief
                  pn is not null
                    and px1 is null
                    and not (px2.stype   is not null and not px2.stype = 'imparative')
                    and not ((px2.tense  is not null and px2.tense = 'past') or
                             (px2.pvagr  is not null and px2.pvagr in ['mv','met-t']) or
                             (px2.pvtijd is not null and px2.pvtijd = 'verl') or
                             (px2.lemma  is not null and px2.lemma in ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben']) )
                  -- einde imperatief
                )))
          )
          return n.sentid, n.id
        </item>
        <item id="spod-nppas-tel" lbl="telling">
          -- niet voor Corpus Gesproken Nederlands

          match (n:nw)&lt;-[:rel{rel: 'vc'}]-()
          match (n)&lt;-[:rel]-()-[:rel{rel: 'hd'}]->(n1)
          match (n)&lt;-[:rel]-(n2)
          optional match (pn:node{cat: 'sv1'})-[:rel]->(n)
          optional match (pn)-[:rel{rel: 'su'}]->(px1)
          optional match (pn)-[:rel{rel: 'hd'}]->(px2)
          with n, n1, n2, pn, px1, px2
          where (n1.sc in ['passive','te_passive']
             or (n1.pt = 'ww'
               and (
                 ( n.cat = 'ppart'
                   and not exists ((n)-[:rel{rel: 'obj1'}]->())
                   and not exists ((n)-[:rel{rel: 'su'}]->())
                   and not exists ((n)-[:rel{rel: 'vc'}]->())
                   and not exists ((n)-[:rel{rel: 'predc'}]->()) )
                 or ( n.cat = 'ti'
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'obj1'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'su'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'vc'}]->())
                   and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'predc'}]->()) )
               ))
          ) and (
            -- n2 is een parent van n
            not exists((n2)-[:rel{rel: 'su'}]->())
            and (
              n2.cat in ['smain','ssub']
              or (
                n2.cat = 'sv1'
                and not (
                  -- imperatief
                  pn is not null
                    and px1 is null
                    and not (px2.stype   is not null and not px2.stype = 'imparative')
                    and not ((px2.tense  is not null and px2.tense = 'past') or
                             (px2.pvagr  is not null and px2.pvagr in ['mv','met-t']) or
                             (px2.pvtijd is not null and px2.pvtijd = 'verl') or
                             (px2.lemma  is not null and px2.lemma in ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben']) )
                  -- einde imperatief
                )))
          )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
    </item>

    <item id="spod-wwsch" lbl="Scheidbare werkwoorden">
      <item id="spod-wwsch-info" lbl="Info" class="info">
        De queries voor scheidbare werkwoorden zijn niet beschikbaar voor de handmatig geannoteerde corpora.

        Werkwoorden met een scheidbaar partikel worden gegeven in (1) en (2).

        |      |    |
        | ---: | -- |
        | (1a) | Ik heb hem opgebeld |
        |   b) | Ik bel hem op |
        |   c) | Ik heb hem op willen bellen |

        We maken daarbij een onderscheid tussen gevallen waarbij het partikel
        gescheiden is van het werkwoord (1bc) en gevallen waarbij het partikel
        in het werkwoord geincorporeerd is (1a).

        Daarnaast bekijken we de gevallen waarbij het werkwoord niet finiet is (1ac).
        En binnen die gevallen onderscheiden we opnieuw gevallen waarbij het partikel
        gescheiden is van het werkwoord (1c) en gevallen waarbij het partikel in het
        werkwoord geincorporeerd is (1a).
      </item>
      <item id="spod-vpart" lbl="Werkwoorden met een scheidbaar partikel">
        <item id="spod-vpart-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          return w.sentid, w.id
        </item>
        <item id="spod-vpart-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-vpartex" lbl="Werkwoorden met een scheidbaar partikel, partikel gescheiden van het werkwoord">
        <item id="spod-vpartex-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and w2.frame starts with 'particle'
          return w.sentid, w.id
        </item>
        <item id="spod-vpartex-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and w2.frame starts with 'particle'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-vpartin" lbl="Werkwoorden met een scheidbaar partikel, partikel geïncorporeerd in het werkwoord">
        <item id="spod-vpartin-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          return w.sentid, w.id
          except
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and w2.frame starts with 'particle'
          return w.sentid, w.id
        </item>
        <item id="spod-vpartin-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (w:word)
            where w.sc starts with 'part_'
            return distinct w.sentid, w.id
            except
            match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
            where w.sc starts with 'part_'
              and w2.frame starts with 'particle'
            return distinct w.sentid, w.id
          ) as foo
        </item>
      </item>
      <item id="spod-vprtn" lbl="Niet-finiete werkwoorden met een scheidbaar partikel">
        <item id="spod-vprtn-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
          return w.sentid, w.id
        </item>
        <item id="spod-vprtn-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-vprtnex" lbl="Niet-finiete werkwoorden met een scheidbaar partikel, partikel gescheiden van het werkwoord">
        <item id="spod-vprtnex-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
            and w2.frame starts with 'particle'
          return w.sentid, w.id
        </item>
        <item id="spod-vprtnex-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
            and w2.frame starts with 'particle'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-vprtnin" lbl="Niet-finiete werkwoorden met een scheidbaar partikel, partikel geïncorporeerd in het werkwoord">
        <item id="spod-vprtnin-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
          return w.sentid, w.id
          except
          match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
            and (w.wvorm is null or w.wvorm != 'pv')
            and w2.frame starts with 'particle'
          return w.sentid, w.id
        </item>
        <item id="spod-vprtnin-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (w:word)
            where w.sc starts with 'part_'
              and (w.wvorm is null or w.wvorm != 'pv')
            return distinct w.sentid, w.id
            except
            match (w:word)&lt;-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
            where w.sc starts with 'part_'
              and (w.wvorm is null or w.wvorm != 'pv')
              and w2.frame starts with 'particle'
            return distinct w.sentid, w.id
          ) as foo
        </item>
      </item>
    </item>

    <item id="spod-inb" lbl="Inbedding">
      <item id="spod-inb-info" lbl="Info" class="info">
        Bij deze queries wordt gekeken naar de complexiteit van de zinnen in termen
        van de inbedding van finitie bijzinnen. Een hoofdzin zonder finiete bijzin
        geldt dan als "geen inbedding". Een hoofdzin met een finiete bijzin geldt als
        "minstens 1 finiete zinsinbedding. Indien de finiete bijzin zelf ook een finiete
        bijzin bevat is er sprake van minstens 2 finiete zinsinbeddingen. En zo verder.
      </item>
      <item id="spod-inb-all" lbl="telling van alle niveaus">
        match (n:node{_clause: true})
        optional match (n)-[:rel*1..]->(n2:node{sentid:n.sentid, _clause: true})
        with n, n2
        where n2 is null
        return n._clause_lvl - 1 as niveau, count(*) as aantal
        order by niveau
      </item>
      <item id="spod-inb0" lbl="geen inbedding">
        match (n:node{_clause_lvl: 1})
        optional match (n)-[:rel*1..]->(n2:node{sentid:n.sentid, _clause: true})
        with n, n2
        where n2 is null
        return n
      </item>
      <item id="spod-inb1" lbl="minstens 1 finiete zinsinbedding">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 1
        return p
      </item>
      <item id="spod-inb2" lbl="minstens 2 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 2
        return p
      </item>
      <item id="spod-inb3" lbl="minstens 3 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 3
        return p
      </item>
      <item id="spod-inb4" lbl="minstens 4 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 4
        return p
      </item>
      <item id="spod-inb5" lbl="minstens 5 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 5
        return p
      </item>
      <item id="spod-inb6" lbl="minstens 6 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 6
        return p
      </item>
      <item id="spod-inb7" lbl="minstens 7 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 7
        return p
      </item>
      <item id="spod-inb8" lbl="minstens 8 finiete zinsinbeddingen">
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 8
        return p
      </item>
    </item>

    <item id="sod-topiextr" lbl="Topicalisatie en Extractie">
      <item id="spod-topiextr-info" lbl="Info" class="info">
        De eerste query, "np-topic is subject", bekijkt hoe vaak in een
        hoofdzin die met een NP begint, deze NP als subject van de persoonsvorm
        fungeert (1), terwijl de tweede query die gevallen telt waarbij zo'n NP
        een andere rol bekleedt (2). De derde query, "topic is niet lokaal",
        identificeert de gevallen waarbij de eerste constituent van de hoofdzin
        geen rol speelt in die hoofdzin, maar een rol speelt in een ingebedde
        constituent. Bij de vierde en vijfde query wordt onderzocht hoe vaak
        in een wh-vraag of relatieve bijzin het wh-element, dan wel de woordgroep
        die het relatieve voornaamwoord bevat een rol speelt in de hoofdzin
        (lokaal, 4) dan wel in een ingebedde bijzin (niet lokaal, 5).

        |      |    |
        | ---: | -- |
        | (1)  | De kinderen geloven nog in Sinterklaas |
        |      | &amp;nbsp; |
        | (2)  | Sinterklaas keurden ze geen blik waardig |
        |      | &amp;nbsp; |
        | (3)  | Wie denk je dat ik tegenkwam? |
        |      | &amp;nbsp; |
        | (4)  | Welke procedure moet worden gevolgd? |
        |      | &amp;nbsp; |
        | (5)  | Ze keek alleen naar wat ze dacht dat het Amerikaanse belang was |
      </item>
      <item id="spod-nptsub" lbl="np-topic is subject">
        <item id="spod-nptsub-zin" lbl="zinnen">
          match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
          where r.rel in ['su','sup'] and r.id is null
          return n.sentid, n.id
        </item>
        <item id="spod-nptsub-tel" lbl="telling">
          match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
          where r.rel in ['su','sup'] and r.id is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
      <item id="spod-nptnsub" lbl="np-topic is geen subject">
        <item id="spod-nptnsub-zin" lbl="zinnen">
          match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
          where r.id is null
          return n.sentid, n.id
          except
          match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
          where r.id is null and r.rel in ['su','sup']
          return n.sentid, n.id
        </item>
        <item id="spod-nptnsub-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
            where r.id is null
            return distinct n.sentid, n.id
            except
            match (n:nw{_vorfeld: true, _np: true})&lt;-[r:rel]-()
            where r.id is null and r.rel in ['su','sup']
            return distinct n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-tnonloc" lbl="topic is niet lokaal">
        <item id="spod-tnonloc-zin" lbl="zinnen">
          match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
          where r.id is null
          return n.sentid, n.id
          except
          match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
          match (n)-[:rel*1..]->(n0:node{sentid: n.sentid})-[r2:rel]->()-[:rel*0..]->(:nw{sentid: n.sentid, _vorfeld: true})
          where r.id is null and r2.id is null and n0.cat in ['ssub','smain']
          return n.sentid, n.id
        </item>
        <item id="spod-tnonloc-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
            where r.id is null
            return distinct n.sentid, n.id
            except
            match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
            match (n)-[:rel*1..]->(n0:node{sentid: n.sentid})-[r2:rel]->()-[:rel*0..]->(:nw{sentid: n.sentid, _vorfeld: true})
            where r.id is null and r2.id is null and n0.cat in ['ssub','smain']
            return distinct n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-locext" lbl="lokale extractie">
        <item id="spod-locext-zin" lbl="zinnen">
          match (n:nw)&lt;-[r:rel]-()
          where r.rel in ['whd','rhd']
          return n.sentid, n.id
          except
          match (n:nw)&lt;-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid: n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)&lt;-[:rel]-()&lt;-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
            and n2 is null
          return n.sentid, n.id
        </item>
        <item id="spod-locext-tel" lbl="telling">
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
            match (n:nw)&lt;-[r:rel]-()
            where r.rel in ['whd','rhd']
            return distinct n.sentid, n.id
            except
            match (n:nw)&lt;-[r:rel]-(nn)
            match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid: n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
            optional match (n0)&lt;-[:rel]-()&lt;-[:rel{rel: 'obcomp'}]-(n2)
            with r, n, n0, n2
            where r.rel in ['whd','rhd']
              and n2 is null
            return distinct n.sentid, n.id
          ) as foo
        </item>
      </item>
      <item id="spod-nlocext" lbl="niet-lokale extractie">
        <item id="spod-nlocext-zin" lbl="zinnen">
          match (n:nw)&lt;-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid: n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)&lt;-[:rel]-()&lt;-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
            and n2 is null
          return n.sentid, n.id
        </item>
        <item id="spod-nlocext-tel" lbl="telling">
          match (n:nw)&lt;-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid: n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)&lt;-[:rel]-()&lt;-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
            and n2 is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        </item>
      </item>
    </item>

    <item id="spod-parser" lbl="Parser succes">
      <item id="spod-parser-info" lbl="Info" class="info">
        Dit deel werkt niet voor handmatig geannoteerde corpora.

        De query telt hoevaak de parser een volledige analyse van
        de zin heeft kunnen uitvoeren (dus zonder woorden over te
        slaan of fragmenten te combineren).
      </item>
      <item id="spod-ok" lbl="volledige parse">
        <item id="spod-ok-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1, skips:0})
          return s
        </item>
        <item id="spod-ok-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1, skips:0})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-catcount" lbl="aantal geparste delen">
        -- alleen voor automatisch verwerkte corpora

        match (s:sentence)
        where s.cats is not null
        return s.cats as delen, count(*) as zinnen
        order by delen
      </item>
      <item id="spod-cats0" lbl="geen enkel deel is geparst">
        <item id="spod-cats0-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:0})
          return s
        </item>
        <item id="spod-cats0-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:0})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-cats1" lbl="parse bestaat uit één deel">
        <item id="spod-cats1-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1})
          return s
        </item>
        <item id="spod-cats1-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-cats2" lbl="parse bestaat uit twee losse delen">
        <item id="spod-cats2-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:2})
          return s
        </item>
        <item id="spod-cats2-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:2})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-cats3" lbl="parse bestaat uit drie losse delen">
        <item id="spod-cats3-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:3})
          return s
        </item>
        <item id="spod-cats3-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:3})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-cats4" lbl="parse bestaat uit vier of meer losse delen">
        <item id="spod-cats4-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.cats > 3
          return s
        </item>
        <item id="spod-cats4-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.cats > 3
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-skipcount" lbl="aantal overgeslagen woorden">
        -- alleen voor automatisch verwerkte corpora

        match (s:sentence)
        where s.skips is not null
        return s.skips as &quot;overgeslagen woorden&quot;, count(*) as zinnen
        order by &quot;overgeslagen woorden&quot;
      </item>
      <item id="spod-skips0" lbl="geen enkel woord is overgeslagen">
        <item id="spod-skips0-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:0})
          return s
        </item>
        <item id="spod-skips0-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:0})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-skips1" lbl="een van de woorden is overgeslagen">
        <item id="spod-skips1-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:1})
          return s
        </item>
        <item id="spod-skips1-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:1})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-skips2" lbl="twee van de woorden zijn overgeslagen">
        <item id="spod-skips2-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:2})
          return s
        </item>
        <item id="spod-skips2-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:2})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-skips3" lbl="drie van de woorden zijn overgeslagen">
        <item id="spod-skips3-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:3})
          return s
        </item>
        <item id="spod-skips3-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:3})
          return count(*) as zinnen
        </item>
      </item>
      <item id="spod-skips4" lbl="vier of meer van de woorden zijn overgeslagen">
        <item id="spod-skips4-zin" lbl="zinnen">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.skips > 3
          return s
        </item>
        <item id="spod-skips4-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.skips > 3
          return count(*) as zinnen
        </item>
      </item>
    </item>

    <item id="spod-onbekend" lbl="Onbekende woorden">
      <item id="spod-onbekend-info" lbl="Info" class="info">
        Dit deel werkt niet voor handmatig geannoteerde corpora.

        De parser kent een heel scale aan heuristieken om voor woorden die niet
        in het woordenboek staan toch een woordsoort toe te kennen. In deze
        afdeling wordt onderzocht hoe vaak zulke onbekende woorden voorkwamen,
        en op welke manier onbekende woorden alsnog werden behandeld. Eerst wordt
        het totaal aantal woorden gegeven, gevolgd door het aantal woorden dat in
        het woordenboek stond. De derde query geeft het aantal onbekende woorden terug.
        De drie volgende queries geven vervolgens aan hoevaak een onbekend woord als
        samenstelling werd gezien, of als naam (maar niet uit de namenlijst) of op
        een nog andere manier werden behandeld.
      </item>
      <item id="spod-his" lbl="&quot;alle&quot; woorden (nodes met attribuut @his)">
        <item id="spod-his-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
          return w
        </item>
        <item id="spod-his-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
          return count(*) as woorden
        </item>
      </item>
      <item id="spod-normal" lbl="woorden uit het woordenboek of de namenlijst">
        <item id="spod-normal-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'normal'})
          return w
        </item>
        <item id="spod-normal-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'normal'})
          return count(*) as woorden
        </item>
      </item>
      <item id="spod-onbeken" lbl="woorden niet direct uit het woordenboek">
        <item id="spod-onbeken-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
            and not (w.his in ['normal','robust_skip','skip'])
          return w
        </item>
        <item id="spod-onbeken-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
            and not (w.his in ['normal','robust_skip','skip'])
          return count(*) as woorden
        </item>
      </item>
      <item id="spod-compoun" lbl="woorden herkend als samenstelling">
        <item id="spod-compoun-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'compound'})
          return w
        </item>
        <item id="spod-compoun-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'compound'})
          return count(*) as woorden
        </item>
      </item>
      <item id="spod-name" lbl="woorden herkend als naam (maar niet uit namenlijst)">
        <item id="spod-name-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'name'})
          return w
        </item>
        <item id="spod-name-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'name'})
          return count(*) as woorden
        </item>
      </item>
      <item id="spod-noun" lbl="onbekende woorden die niet als samenstelling of naam werden herkend">
        <item id="spod-noun-zin" lbl="woorden">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
            and not (w.his in ['normal','compound','name','robust_skip','skip'])
          return w
        </item>
        <item id="spod-noun-tel" lbl="telling">
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
            and not (w.his in ['normal','compound','name','robust_skip','skip'])
          return count(*) as woorden
        </item>
      </item>
    </item>

  </item>

</menu>
