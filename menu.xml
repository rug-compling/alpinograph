<menu>
  <item id="tut" lbl="Voorbeelden">
    <item id="tut-inl" lbl="Inleiding">
      <item id="tut-inl-node" lbl="Node"><![CDATA[
        -- Een vertex in de graaf dat geen woord is
        -- (of een multi-word unit)

        match (n:node)
        return n
        limit 10
      ]]></item>
      <item id="tut-inl-word" lbl="Woord"><![CDATA[
        match (w:word)
        return w
        limit 10
      ]]></item>
      <item id="tut-inl-nw" lbl="Node of woord"><![CDATA[
        -- :nw is een alias voor :node en :word samen

        match (n:nw)
        return n
        limit 10
      ]]></item>
      <item id="tut-inl-zin" lbl="Zin"><![CDATA[
        match (s:sentence)
        return s
        limit 10
      ]]></item>
      <item id="tut-inl-meta" lbl="Metadata"><![CDATA[
        match (m:meta)
        return m.sentid as "sentence ID", m.type, m.name, m.value
        limit 10
      ]]></item>
      <item id="tut-inl-attr" lbl="Attributen"><![CDATA[
        -- Tellingen van verschillende soorten attributen

        match (f:feature)
        return f
        limit 10
      ]]></item>
      <item id="tut-inl-rel" lbl="Relatie"><![CDATA[
        match ()-[r]->()
        return r
        limit 10
      ]]></item>
      <item id="tut-inl-roor" lbl="Root"><![CDATA[
        -- :sentence fungeert als root voor verschillende soorten relaties

        match (:sentence)-[r]->()
        return r
        limit 10
      ]]></item>
      <item id="tut-inl-corpus" lbl="Datainvoer"><![CDATA[
        -- extra informatie toegevoegd bij het inlezen van het corpus

        match (d:doc)
        return d
      ]]></item>
    </item>
    <item id="tut-next" lbl="Woorden en woordgroepen">
      <item id="tut-next-next" lbl="De next-relatie"><![CDATA[
        -- De relatie :next verbindt twee opeenvolgende woorden met elkaar

        match p = ()-[:next]->()
        return p
      ]]></item>
      <item id="tut-next-first" lbl="De eerste twee woorden van de zin"><![CDATA[
        match p = (:word{begin:0})-[:next]->()
        return p
      ]]></item>
      <item id="tut-next-last" lbl="De laatste twee woorden van de zin"><![CDATA[
        match p = ()-[:next]->(:word{last:true})
        return p
      ]]></item>
      <item id="tut-next-woorden" lbl="Woorden in dezelfde zin"><![CDATA[
        -- Zoek zinnen met zowel 'dag' als 'jaar'

        match (w1:word{lemma: 'dag'}),
        (w2:word{sentid: w1.sentid, lemma: 'jaar'})
        return w1, w2
      ]]></item>
      <item id="tut-next-near" lbl="Woorden bij elkaar in de buurt"><![CDATA[
        -- Zoek zinnen met zowel 'dag' als 'jaar'
        -- Maximaal twee andere woorden tussen 'dag' en 'jaar'
        -- Omdat de link geen richting bevat is de volgorde vrij

        match p = (:word{lemma: 'dag'})-[:next*1..3]-(:word{lemma: 'jaar'})
        return p
      ]]></item>
      <item id="tut-next-groep" lbl="Woordgroepen"><![CDATA[
        -- Welke woord volgt het vaakst na 'per'?

        match (:word{lemma: 'per'})-[:next]->(w:word)
        return w.lemma, count(*) as aantal
        order by aantal desc
      ]]></item>
      <item id="tut-next-mwu" lbl="Multi-word units"><![CDATA[
        -- Een multi-word unit is de enige vertex van het type 'node' met de attributen 'word',
        'lemma' en 'pt'
        -- De waarde voor 'pt' is altijd 'mwu', net als voor 'cat' in dit geval

        match (w:node{cat: 'mwu'})
        return w.word, count(*) as aantal
        order by aantal desc
      ]]></item>
      <item id="tut-next-cp1" lbl="Compound parts (1)"><![CDATA[
        -- Het attribuut '_cp' van een 'word' bevat de compound parts van het lemma

        match (w:word)
        where length(w._cp) > 1
        return w.lemma, count(*)
        order by count desc, lemma
      ]]></item>
      <item id="tut-next-cp2" lbl="Compound parts (2)"><![CDATA[
        -- Zoek woorden waarvan het lemma 'fiets' of 'fietsen' bevat

        match (w:word)
        where 'fiets' in w._cp
        or 'fietsen' in w._cp
        return w.word, count(*)
        order by count desc, word
      ]]></item>
    </item>
    <item id="tut-pair" lbl="Woordpaar-relaties">
      <item id="tut-pair-pair" lbl="De pair-relatie"><![CDATA[
        match p = (:word)-[:pair]->(:word)
        return p
      ]]></item>
      <item id="tut-pair-graag" lbl="Wat doen we graag?"><![CDATA[
        -- Werkwoorden met 'graag' als modifier

        match p = (:nw{pt: 'ww'})-[:pair{rel: 'mod'}]->(:word{lemma: 'graag'})
        return p
      ]]></item>
      <item id="tut-pair-eten" lbl="Wat wordt er gegeten?"><![CDATA[
        -- Zelfstandig naamwoorden als 'obj1' van het werkwoord 'eten' of 'opeten'

        match (w1:word{pt: 'ww'})-[:pair{rel: 'obj1'}]->(w:word{pt: 'n'})
        where w1.lemma in ['eten', 'opeten']
        return w.lemma, count(*) as aantal
        order by aantal desc
      ]]></item>
      <item id="tut-pair-obj12" lbl="Werkwoorden met lijdend voorwerp en meewerkend voorwerp"><![CDATA[
        match (w1:nw)<-[:pair{rel:'obj1'}]-(w:word{pt:'ww'})-[:pair{rel:'obj2'}]->(w2:nw)
        where w1.pt in ['n', 'mwu']
        and w2.pt in ['n', 'mwu']
        return w.lemma as werkwoord, w1.word as "lijdend voorwerp", w2.word as "meewerkend voorwerp"
      ]]></item>
    </item>
    <item id="tut-rel" lbl="Alpino-structuren">
      <item id="tut-rel-attrib" lbl="Alpino-attributen: een onvoltooid deelwoord"><![CDATA[
        match (w:word{wvorm:'od'})
        return w
      ]]></item>
      <item id="tut-rel-conj" lbl="Alpino-attributen: een conjunctie"><![CDATA[
        match (n:node{cat:'conj'})
        return n
      ]]></item>
      <item id="tut-rel-nwords" lbl="Aantal woorden in een mededelende hoofdzin"><![CDATA[
        match (n:node{cat: 'smain'})
        return n._n_words, count(*)
        order by _n_words
      ]]></item>
      <item id="tut-rel-rel" lbl="De Alpino-relatie"><![CDATA[
        match p = (:node)-[:rel]->(:nw)
        return p
      ]]></item>
      <item id="tut-rel-rela" lbl="Relatieve zinsdelen"><![CDATA[
        match p = (:node{cat:'rel'})-[:rel{rel:'body'}]->(:node{cat:'ssub'})
        return p
      ]]></item>
      <item id="tut-rel-kind" lbl="Onderwerpen die het lemma &#39;kind&#39; bevatten"><![CDATA[
        match (:node)-[:rel{rel:'su'}]->(n:nw)-[:rel*0..]->(:word{lemma: 'kind'})
        return n
      ]]></item>
      <item id="tut-rel-mwu-van" lbl="Multi-word units die eindigen met &#39;van&#39;"><![CDATA[
        match (n:node{cat:'mwu'})-[:rel{rel:'mwp'}]->(:word{lemma:'van', end:n.end})
        return n.word as "multi-word unit", count(*) as aantal
        order by aantal desc, "multi-word unit"
      ]]></item>
      <item id="tut-rel-pdp" lbl="Node met twee parents"><![CDATA[
        -- In Alpino kan een node maar één parent hebben
        -- In AlpinoGraph zijn nodes met een identieke index versmolten, waardoor
        -- een node meer dan één parent kan hebben

        match m = (n1:node)-[:rel]->()<-[:rel]-(n2:node)
        where n1.id < n2.id -- voorkomt dubbelen
        return m
      ]]></item>
    </item>
    <item id="tut-ud" lbl="Universal Dependencies">
      <item id="tut-ud-upos" lbl="Universal part-of-speech tag"><![CDATA[
        match (w:word{upos:'NOUN'})
        return w
      ]]></item>
      <item id="tut-ud-feat" lbl="Universal morphological features"><![CDATA[
        -- Attributen met hoofdletters in de naam moeten tussen dubbele aanhalingstekens

        match (w:word{upos:'VERB'})
        return w."VerbForm", count(*)
      ]]></item>
      <item id="tut-ud-ud" lbl="De standaard UD-relatie"><![CDATA[
        match p = (:word)-[:ud]->(:word)
        return p
      ]]></item>
      <item id="tut-ud-eud" lbl="De Enhanced UD-relatie"><![CDATA[
        match p = (:word)-[:eud]->(:word)
        return p
      ]]></item>
      <item id="tut-ud-dep" lbl="De dep-relatie"><![CDATA[
        -- :dep is een alias voor :ud en :eud samen

        match p = (:word)-[:dep]->(:word)
        return p
      ]]></item>
      <item id="tut-ud-nsubj" lbl="Onderwerp"><![CDATA[
        match ()-[:ud{main:'nsubj'}]->(w)
        return w
      ]]></item>
      <item id="tut-ud-pos" lbl="Possessieven"><![CDATA[
        match (w1:word)-[:ud{rel:'nmod:poss'}]->(w2:word)
        return w1, w2
      ]]></item>
      <item id="tud-ud-wwobj" lbl="Werkwoord met object dat geen persoonlijk voornaamwoord is"><![CDATA[
        match (w1:word{upos:'VERB'})-[:ud{main:'obj'}]->(w2:word)
        where w2.upos != 'PRON'
        return w1, w2
      ]]></item>
      <item id="tut-ud-reeks" lbl="Een advmod van een amod van een zelfstandig naamwoord"><![CDATA[
        match p = (:word{upos:'NOUN'})-[:ud{main:'amod'}]->()-[:ud{main:'advmod'}]->()
        return p
      ]]></item>
    </item>
    <item id="tut-mix" lbl="Heterogene relaties">
      <item id="tut-mix-udmwu" lbl="Universal Dependencies en multi-word units (1)"><![CDATA[
        -- Universal dependencies zijn altijd tussen woorden
        -- Soms is dat met een woord dat het begin van een multi-word unit is
        -- en wil je de hele multi-word unit weten
        -- Daarvoor kun je UD-relaties [:ud] combineren met Alpino-relaties [:rel]

        match (:word{lemma:'gebruiken'})-[:ud{rel:'obj'}]->(v1:word)<-[:rel*0..1{rel:'mwp'}]-(v)
        where not exists ( (v)<-[:rel{rel:'mwp'}]-() )
        return v.lemma
      ]]></item>
      <item id="tut-mix-udmwu2" lbl="Universal Dependencies en multi-word units (2)"><![CDATA[
        -- Hier zoek je expliciet naar Universal Dependencies met een multi-word unit

        match (w:word)-[u:ud]->(:word)<-[:rel]-(n:node{cat:'mwu'})
        where not u.main in ['flat','fixed']
        return w.lemma, u.rel, n.word
      ]]></item>
      <item id="tut-mix-cop" lbl="Nominalisaties van copula-constructies"><![CDATA[
        -- Voor de gevorderde taalkundige
        -- Ook hier wordt een UD-relatie gecombineerd met een Alpino-relatie

        match p = (:node{cat:'np'})-[:rel{rel:'hd'}]->(:word)<-[:ud{main:'cop'}]-(:word)
        return p
      ]]></item>
    </item>
    <item id="tut-meta" lbl="Metadata">
      <item id="tut-meta-zinnen" lbl="Aantal zinnen per land"><![CDATA[
        -- Dit voorbeeld werk alleen met het Corpus Gesproken Nederlands

        match (m:meta{name: 'country'})
        return m.value as land, count(*) as "aantal zinnen"
      ]]></item>
      <item id="tut-meta-woorden" lbl="Aantal woorden per land"><![CDATA[
        -- Dit voorbeeld werk alleen met het Corpus Gesproken Nederlands

        match (w:word),
        (m:meta{sentid: w.sentid, name: 'country'})
        return m.value as land, count(*) as "aantal woorden"
      ]]></item>
      <item id="tut-meta-gij" lbl="Waar wordt &#39;gij&#39; gebruikt?"><![CDATA[
        -- Dit voorbeeld werk alleen met het Corpus Gesproken Nederlands

        match (w:word{lemma: 'gij'}),
        (m:meta{sentid: w.sentid, name: 'country'})
        return m.value as land, count(*) as aantal
      ]]></item>
      <item id="tut-meta-gij-perc" lbl="Genormaliseerd gebruik van &#39;gij&#39;"><![CDATA[
        -- Dit voorbeeld werk alleen met het Corpus Gesproken Nederlands

        select land,
        case when land ? 'BE' then aantal::text::numeric / 379916 -- aantal woorden in BE
        when land ? 'NL' then aantal::text::numeric / 753845 -- aantal woorden in NL
        else 0
        end as "per woord"
        from
        (
        match (w:word{lemma: 'gij'}),
        (m:meta{sentid: w.sentid, name: 'country'})
        return m.value as land, count(*) as aantal
        ) as foo
      ]]></item>
    </item>
    <item id="software" lbl="Software">
      <item id="software-version" lbl="Versies"><![CDATA[
        select version() as "PostgreSQL version", agversion() as "AgensGraph version"
      ]]></item>
    </item>
  </item>
  <item id="idx" lbl="Corpusinformatie">
    <item id="idx-node" lbl="Attributen van nodes"><![CDATA[
      match (f:feature{v: 'node'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    ]]></item>
    <item id="idx-word" lbl="Attributen van woorden"><![CDATA[
      match (f:feature{v: 'word'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    ]]></item>
    <item id="idx-rel" lbl="Attributen van relaties"><![CDATA[
      match (f:feature{v: 'rel'})
      return f.name as attribuut, f.count as aantal
      order by attribuut
    ]]></item>
    <item id="idx-meta" lbl="Soorten metadata, indien aanwezig"><![CDATA[
      match (f:feature{v: 'meta'})
      return f.name as metadata, f.count as aantal
      order by metadata
    ]]></item>
    <item id="idx-doc" lbl="Bij de invoer van het corpus"><![CDATA[
      match (d:doc)
      return d
    ]]></item>
  </item>
  <item id="spod" lbl="SPOD">
    <item id="spod-info" lbl="Info" class="info"><![CDATA[
      De *Syntactic profiler of Dutch* bestaat uit een grote set tests
      waarmee een profiel van een corpus kan worden opgesteld. SPOD is
      ontwikkeld in [PaQu](https://www.let.rug.nl/alfa/paqu/spod), en maakt
      gebruik van query's in XPath. Zie paper:
      > Gertjan van Noord, Jack Hoeksema, Peter Kleiweg, and Gosse Bouma. 2020. <br>
      > [SPOD: Syntactic profiler of Dutch.](https://www.clinjournal.org/clinj/article/view/110)
      <br>
      > *Computational Linguistics in the Netherlands Journal*, 10, pages 129--145. <br>

      Voor AlpinoGraph zijn al de SPOD-query's herschreven in Cypher. De
      resultaten die je krijgt met deze nieuwe versies zijn niet altijd gelijk aan
      de resultaten die je kreeg in PaQu, voornamelijk vanwege de technische
      beperkingen van de oorspronkelijke query's in XPath. Zie paper:
      > Peter Kleiweg and Gertjan van Noord. 2020. <br>
      > [AlpinoGraph: A Graph-based search engine for flexible and efficient treebank
      search.](https://www.aclweb.org/anthology/2020.tlt-1.13/) <br>
      > In *Proceedings of the 19th International Workshop on Treebanks and Linguistic Theories*,
      > pages 151--161, Düsseldorf, Germany, 27--28 October. Association for Computational
      Linguistics. <br>
    ]]></item>
    <item id="spod-attrib" lbl="Attributen">
      <item id="spod-attrib-info" lbl="Info" class="info"><![CDATA[
        Hier worden de woordsoorten geteld. De Lassy part-of-speech labels
        worden geteld via het attribuut **postag**. Er is daarnaast een
        attribuut **pt** dat de vereenvoudigde weergave geeft van dezelfde
        informatie: het deel van de postag tot aan het openingshaakje. De
        documentatie van postag is te vinden in: Frank van Eynde, [Part of
        speech tagging en lemmatisering van het D-Coi
        corpus](http://www.let.rug.nl/vannoord/Lassy/POS_manual.pdf), 2005.

        Vanwege historische redenen wordt hier ook het attribuut **pos**
        opgenomen, maar dit attribuut wordt niet langer onderhouden, is ook
        niet gedocumenteerd en wordt ook niet gecorrigeerd in de handmatig
        geannoteerde corpora.

        Ook geven we hier een overzicht van de categorie van de uiting (de "zin")
        als geheel. Dat zijn immers niet altijd zinnen, maar soms ook
        naamwoordgroepen of nog andere categorieën.
      ]]></item>
      <item id="spod-pos" lbl="pos"><![CDATA[
        match (w:word)
        return w.pos as pos, count(*) as aantal
        order by pos
      ]]></item>
      <item id="spod-postag" lbl="postag"><![CDATA[
        match (w:word)
        return w.postag as postag, count(*) as aantal
        order by postag
      ]]></item>
      <item id="spod-pt" lbl="pt"><![CDATA[
        match (w:word)
        return w.pt as pt, count(*) as aantal
        order by pt
      ]]></item>
      <item id="spod-toptag" lbl="categorie van de gehele uiting"><![CDATA[
        match (:node{cat: 'top'})-[:rel]->(n:node)
        return n.cat as cat, count(*) as aantal
        order by cat
      ]]></item>
    </item>
    <item id="spod-sents" lbl="Hoofdzinnen">
      <item id="spod-sents-info" lbl="Info" class="info"><![CDATA[
        Bij deze queries vergelijken we de verschillende typen hoofdzinnen:
        mededelende hoofdzinnen (1), vraagzinnen die met een vraag-constituent
        beginnen (2), ja/nee vragen (3), en imperatieven (4).

        | | |
        | ---: | -- |
        | (1) | Pieter leest een boek. |
        | | &nbsp; |
        | (2) | Wie leest er een boek? |
        | | &nbsp; |
        | (3) | Lees jij een boek? |
        | | &nbsp; |
        | (4a) | Lees dat boek nou toch eens. |
        | b) | Lees jij dat boek nou toch eens. |

        Het onderscheid tussen ja/nee vragen en imperatieven is in de
        treebanks niet altijd nauwkeurig te bepalen --- met name voor
        de handmatig geannoteerde treebanks die iets minder informatie
        bevatten dan de automatisch geannoteerde treebanks. Bijvoorbeeld
        imperatieven die wel een onderwerp bevatten (4b) zullen door de
        bestaande queries niet worden gevonden als imperatief.
      ]]></item>
      <item id="spod-smain" lbl="mededelende hoofdzinnen">
        <item id="spod-smain-zin" lbl="zinnen"><![CDATA[
          match p = (:node{cat: 'smain'})
          return p
        ]]></item>
        <item id="spod-smain-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'smain'})
          with n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-whq" lbl="vraagzinnen (wh)">
        <item id="spod-whq-zin" lbl="zinnen"><![CDATA[
          match p = (:node{cat: 'whq'})
          return p
        ]]></item>
        <item id="spod-whq-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'whq'})
          with n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-janee" lbl="ja/nee vragen">
        <item id="spod-janee-zin" lbl="zinnen"><![CDATA[
          match (w:word{word: '?'}) ,
          (n:node{sentid:w.sentid,cat: 'sv1'})<-[r:rel]-()
          optional match (n)-[:rel{rel: 'hd'}]->(n1)
          with w, r, n, n1
          where not r.rel = 'body'
          and n.end < w.end
          and (n1 is null or n1.stype is null or n1.stype = 'ynquestion')
          return n.sentid, n.id
        ]]></item>
        <item id="spod-janee-tel" lbl="telling"><![CDATA[
          match (w:word{word: '?'}) ,
          (n:node{sentid:w.sentid,cat: 'sv1'})<-[r:rel]-()
          optional match (n)-[:rel{rel: 'hd'}]->(n1)
          with w, r, n, n1
          where not r.rel = 'body'
          and n.end < w.end
          and (n1 is null or n1.stype is null or n1.stype = 'ynquestion')
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-imp" lbl="imperatieven">
        <item id="spod-imp-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'sv1'})
          optional match (n)-[:rel{rel: 'su'}]->(x1)
          optional match (n)-[:rel{rel: 'hd'}]->(x2)
          with n, x1, x2
          where x1 is null
          and not (x2.stype is not null and not x2.stype = 'imparative')
          and not ((x2.tense is not null and x2.tense = 'past') or
          (x2.pvagr is not null and x2.pvagr in ['mv','met-t']) or
          (x2.pvtijd is not null and x2.pvtijd = 'verl') or
          (x2.lemma is not null and x2.lemma in
          ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben'])
          )
          return n.sentid, n.id
        ]]></item>
        <item id="spod-imp-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'sv1'})
          optional match (n)-[:rel{rel: 'su'}]->(x1)
          optional match (n)-[:rel{rel: 'hd'}]->(x2)
          with n, x1, x2
          where x1 is null
          and not (x2.stype is not null and not x2.stype = 'imparative')
          and not ((x2.tense is not null and x2.tense = 'past') or
          (x2.pvagr is not null and x2.pvagr in ['mv','met-t']) or
          (x2.pvtijd is not null and x2.pvtijd = 'verl') or
          (x2.lemma is not null and x2.lemma in
          ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben'])
          )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-bijzinnen" lbl="Bijzinnen">
      <item id="spod-bijzinnen-info" lbl="Info" class="info"><![CDATA[
        Deze queries vergelijken de verschillende soorten bijzinnen.
        We onderscheiden de volgende bijzinnen: ingebedde vraagzinnen
        met een vraag-constituent (1), finiete bijzinnen (2), infiniete
        bijzinnen met *om te* (3) infiniete bijzinnen met alleen *te* (4),
        en infiniete bijzinnen met een ander voorzetsel (5). Daarnaast
        onderscheiden we relatieve bijzinnen (6) en free relatives (7).

        | | |
        | ---: | -- |
        | (1) | (ik vroeg) wie dat boek gelezen heeft |
        | | &nbsp; |
        | (2a) | (ik lees dat boek) omdat het door Elsschot geschreven is |
        | b) | (ik denk) dat het boek door Elsschot is geschreven |
        | c) | (ik vroeg) of het boek door Ellschot is geschreven |
        | | &nbsp; |
        | (3a) | (ik heb geprobeerd) om een boek te lezen |
        | b) | (ik ga naar de bieb) om een boek te lezen |
        | c) | (het was niet nodig) om het boek te lezen |
        | d) | (slangen zijn) om van te gruwen |
        | e) | (het kind is oud genoeg) om alleen naar school te gaan |
        | f) | (het boek is te duur) om te kopen |
        | g) | (hij heeft voldoende invloed) om het boek te verkopen |
        | h) | (ze was zo genadig) om het boek voor te lezen |
        | i) | (een boek) om nooit te vergeten |
        | | &nbsp; |
        | (4) | (ik heb geprobeerd) een boek te lezen |
        | | &nbsp; |
        | (5) | (ik lees dat boek) zonder mijn oordeel uit te spreken |
        | | &nbsp; |
        | (6) | (ik lees een boek) dat door Elsschot is geschreven |
        | | &nbsp; |
        | (7) | wie dit leest (is gek) |

        Binnen de finiete bijzinnen maken we onderscheid tussen bijzinnen die
        ingeleid worden met *dat* (2b), met *of* (2c) dan wel met een ander
        voegwoord (2a).

        De infiniete bijzinnen met *om* worden verder onderverdeeld naar
        gelang de bijzin optreedt als complement (3a), of als bepaling (3b),
        als onderwerp (3c), als predicatief complement (3d), of als
        comperatief complement (3efgh). Infiniete bijzinnen die als
        bepaling optreden worden verder onderverdeeld, afhankelijk of
        de bepaling bij een werkwoord optreedt (3b) of bij een zelfstandig
        naamwoord (3i).
      ]]></item>
      <item id="spod-whsub" lbl="ingebedde vraagzinnen">
        <item id="spod-whsub-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'whsub'})-[:rel*1..2]->(n2:node{cat: 'ssub'})
          where exists ((n)-[:rel{rel: 'body'}]->(n2))
          or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->(n2))
          or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'du'})-[:rel]->(n2))
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-whsub-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'whsub'})-[:rel*1..2]->(n2:node{cat: 'ssub'})
          where exists ((n)-[:rel{rel: 'body'}]->(n2))
          or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->(n2))
          or exists ((n)-[:rel{rel: 'body'}]->(:node{cat: 'du'})-[:rel]->(n2))
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ssub" lbl="finiete bijzinnen">
        <item id="spod-ssub-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-ssub-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ssubdat" lbl="finiete bijzinnen met &#34;dat&#34;">
        <item id="spod-ssubdat-zin" lbl="zinnen"><![CDATA[
          match (n1:word{lemma: 'dat'})<-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel:
          'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, n1.id, n2.id
        ]]></item>
        <item id="spod-ssubdat-tel" lbl="telling"><![CDATA[
          match (:word{lemma: 'dat'})<-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel:
          'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ssubof" lbl="finiete bijzinnen met &#34;of&#34;">
        <item id="spod-ssubof-zin" lbl="zinnen"><![CDATA[
          match (w:word{lemma: 'of'})<-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel:
          'body'}]->(n2:node{cat: 'ssub'})
          return n.sentid, n.id, w.id, n2.id
        ]]></item>
        <item id="spod-ssubof-tel" lbl="telling"><![CDATA[
          match (:word{lemma: 'of'})<-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel:
          'body'}]->(:node{cat: 'ssub'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ssubcmp" lbl="finiete bijzinnen met andere voegwoorden">
        <item id="spod-ssubcmp-zin" lbl="zinnen"><![CDATA[
          match (w:nw)<-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat:
          'ssub'})
          where not (w.lemma is not null and w.lemma in ['of','dat'])
          return n.sentid, n.id, w.id, n2.id
        ]]></item>
        <item id="spod-ssubcmp-tel" lbl="telling"><![CDATA[
          match (w:nw)<-[:rel{rel: 'cmp'}]-(n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat:
          'ssub'})
          where not (w.lemma is not null and w.lemma in ['of','dat'])
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-oti" lbl="infiniete bijzinnen met &#34;om&#34;">
        <item id="spod-oti-zin" lbl="zinnen"><![CDATA[
          match p = (:node{cat: 'oti'})
          return p
        ]]></item>
        <item id="spod-oti-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'oti'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-otivc" lbl="infiniete bijzinnen met &#34;om&#34; die als complement optreden">
        <item id="spod-otivc-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'vc'}]-(n2:node)
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-otivc-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'vc'}]-(:node)
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-otimod" lbl="infiniete bijzinnen met &#34;om&#34; die als bepaling optreden">
        <item id="spod-otimod-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'mod'}]-(n2)
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-otimod-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'mod'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-otiww" lbl="infiniete bijzinnen met &#34;om&#34; die als bepaling bij een werkwoord optreden">
        <item id="spod-otiww-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel]-()-[:rel{rel: 'hd'}]->(w:word{pt: 'ww'})
          return n.sentid, n.id, w.id
        ]]></item>
        <item id="spod-otiww-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel]-()-[:rel{rel: 'hd'}]->(:word{pt: 'ww'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-otin" lbl="infiniete bijzinnen met &#34;om&#34; die als bepaling bij een zelfstandig naamwoord optreden">
        <item id="spod-otin-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel]-()-[:rel{rel: 'hd'}]->(w:word)
          where w.pt in ['n','vnw']
          return n.sentid, n.id, w.id
        ]]></item>
        <item id="spod-otin-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel]-()-[:rel{rel: 'hd'}]->(w:word)
          where w.pt in ['n','vnw']
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-otisu" lbl="infiniete bijzinnen met &#34;om&#34; die als onderwerp fungeren">
        <item id="spod-otisu-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'su'}]-(n2)
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-otisu-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'su'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-otipred" lbl="infiniete bijzinnen met &#34;om&#34; die als predicaat fungeren">
        <item id="spod-otipred-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'predc'}]-(n2)
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-otipred-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'predc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-otiobc" lbl="infiniete bijzinnen met &#34;om&#34; die optreden met combinaties zoals &#34;te ADJ; zo ADJ; genoeg ADJ; voldoende N&#34;">
        <item id="spod-otiobc-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'obcomp'}]-(n2)
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-otiobc-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'oti'})<-[:rel{rel: 'obcomp'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-tite" lbl="infiniete bijzinnen met alleen &#34;te&#34;">
        <item id="spod-tite-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'ti'})<-[:rel]-(n2:node)
          where not n2.cat in ['oti','cp']
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-tite-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'ti'})<-[:rel]-(n2:node)
          where not n2.cat in ['oti','cp']
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ti" lbl="infiniete bijzinnen met ander voorzetsel">
        <item id="spod-ti-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(n2:node{cat: 'ti'})
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-ti-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'cp'})-[:rel{rel: 'body'}]->(:node{cat: 'ti'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-relssub" lbl="relatieve bijzinnen">
        <item id="spod-relssub-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'rel'})-[:rel{rel: 'body'}]->(n1:node)-[r:rel*0..1]->(n2:node{cat:
          'ssub'})
          where length(r) = 0
          or n1.cat = 'conj' and r[0].rel = 'cnj'
          or n1.cat = 'du'
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-relssub-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'rel'})-[:rel{rel: 'body'}]->(n1:node)-[r:rel*0..1]->(n2:node{cat:
          'ssub'})
          where length(r) = 0
          or n1.cat = 'conj' and r[0].rel = 'cnj'
          or n1.cat = 'du'
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-whrel" lbl="free relatives">
        <item id="spod-whrel-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'whrel'})-[:rel{rel: 'body'}]->(n2:node)
          where not exists( (:node)-[:rel{rel: 'mod'}]->(n) )
          and (n2.cat = 'ssub'
          or n2.cat = 'conj' and exists( (n2)-[:rel{rel: 'cnj'}]->(:node{cat: 'ssub'}) )
          or n2.cat = 'du' and exists( (n2)-[:rel]->(:node{cat: 'ssub'}) ) )
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-whrel-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'whrel'})-[:rel{rel: 'body'}]->(n2:node)
          where not exists( (:node)-[:rel{rel: 'mod'}]->(n) )
          and (n2.cat = 'ssub'
          or n2.cat = 'conj' and exists( (n2)-[:rel{rel: 'cnj'}]->(:node{cat: 'ssub'}) )
          or n2.cat = 'du' and exists( (n2)-[:rel]->(:node{cat: 'ssub'}) ) )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-corc" lbl="Correlatieve comparatieven">
      <item id="spod-corc-info" lbl="Info" class="info"><![CDATA[
        Correlatieve comparatieven zijn zinnen zoals:

        | | |
        | --: | -- |
        | (1) | Hoe langer, hoe beter |
        | | &nbsp; |
        | (2) | Hoe langer hij wordt, des te meer hij last van zijn rug krijgt |
      ]]></item>
      <item id="spod-corc-zin" lbl="zinnen"><![CDATA[
        match p1 = (n1:node{_deste: true})<-[:rel*0..]-(n0:node)<-[:rel*0..]-(n:node{cat:
        'du'})
        match p2 = (n1)<-[:rel*0..]-(n0)-[:rel*0..]->(n2:node{_deste: true})
        optional match p = (n0)<-[:rel*0..]-(:node{cat:'du'})<-[:rel*1..]-(n)
        with n1, n2, p, p1, p2
        where n1.id < n2.id
        and p is null
        return p1, p2
      ]]></item>
      <item id="spod-corc-tel" lbl="telling"><![CDATA[
        match (n1:node{_deste: true})<-[:rel*0..]-(n0:node)<-[:rel*0..]-(n:node{cat: 'du'})
        match (n1)<-[:rel*0..]-(n0)-[:rel*0..]->(n2:node{_deste: true})
        optional match p = (n0)<-[:rel*0..]-(:node{cat:'du'})<-[:rel*1..]-(n)
        with n, n1, n2, p
        where n1.id < n2.id
        and p is null
        with distinct n.sentid as sentid, n.id as id
        return count(distinct(sentid)) as zinnen, count(*) as items
      ]]></item>
    </item>
    <item id="spod-compcomp" lbl="Woorden met een comparatief complement">
      <item id="spod-compcomp-info" lbl="Info" class="info"><![CDATA[
        Comparatieve adjectieven en woorden zo als *zo*, *even*, *meer*,
        *minder*, *niet*, *niets*, *ander*, *anders* treden soms op met
        een complement dat vaak wordt ingeleid met het woord *dan* of *als*.
        Naast het totale aantal voorkomens van de constructie kijken we naar
        het aantal voorbeelden waarbij *zo* (1) of *even* (2) of een
        comparatief adjective (3) of *meer* of *minder* (4) of *niet*,
        *niets*, *ander*, *anders* (5) het hoofd is.

        Bij comparatieve adjectieven make we ook nog een onderverdeling
        naar de aard van het complement. Een vergelijkbare onderverdeling
        wordt gemaakt voor de andere hoofden.

        | | |
        | ---: | -- |
        | (1) | zo groen als gras |
        | | &nbsp; |
        | (2) | even dik als jij |
        | | &nbsp; |
        | (3a) | beter dan jij |
        | b) | beter dan ik dacht |
        | c) | beter dan bij de buren |
        | d) | beter dan gisteren |
        | | &nbsp; |
        | (4a) | meer geluk dan wijsheid |
        | b) | meer geluk dan ik dacht |
        | c) | meer geluk dan bij de buren |
        | d) | meer geluk dan gisteren |
        | | &nbsp; |
        | (5a) | niets anders dan ellende |
        | b) | niets anders dan dat hij komt |
        | c) | niets anders dan bij de buren |
        | d) | niets anders dan gisteren |
      ]]></item>
      <item id="spod-cc" lbl="totaal">
        <item id="spod-cc-zin" lbl="zinnen"><![CDATA[
          match (n:nw)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-cc-tel" lbl="telling"><![CDATA[
          match (n:nw)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cczo" lbl="met als hoofd &#34;zo&#34;">
        <item id="spod-cczo-zin" lbl="zinnen"><![CDATA[
          match (w:word{lemma: 'zo'})<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return w.sentid, w.id, n2.id
        ]]></item>
        <item id="spod-cczo-tel" lbl="telling"><![CDATA[
          match (w:word{lemma: 'zo'})<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cceven" lbl="met als hoofd &#34;even&#34;">
        <item id="spod-cceven-zin" lbl="zinnen"><![CDATA[
          match (w:word{lemma: 'even'})<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          return distinct w.sentid, w.id, n2.id
        ]]></item>
        <item id="spod-cceven-tel" lbl="telling"><![CDATA[
          match (w:word{lemma: 'even'})<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccca" lbl="met als hoofd comparatief adjectief">
        <item id="spod-ccca-zin" lbl="zinnen"><![CDATA[
          match (n:word{pt: 'adj', graad: 'comp'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'obcomp'}]->(n2)
          return n.sentid, n.id, n2.id
        ]]></item>
        <item id="spod-ccca-tel" lbl="telling"><![CDATA[
          match (n:word{pt: 'adj', graad: 'comp'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'obcomp'}]->()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccdannp" lbl="met als hoofd comparatief adjectief, gevolgd door NP">
        <item id="spod-ccdannp-zin" lbl="zinnen"><![CDATA[
          match (w:word{pt: 'adj', graad: 'comp'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'obcomp'}]->(n2)-[:rel{rel: 'body'}]->(x{_np:true})
          return w.sentid, w.id, n2.id, x.id
        ]]></item>
        <item id="spod-ccdannp-tel" lbl="telling"><![CDATA[
          match (w:word{pt: 'adj', graad: 'comp'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'obcomp'}]->()-[:rel{rel: 'body'}]->(x{_np:true})
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccdanvs" lbl="met als hoofd comparatief adjectief, gevolgd door VP of S">
        <item id="spod-ccdanvs-zin" lbl="zinnen"><![CDATA[
          match (w:word{pt: 'adj', graad: 'comp'})<-[:rel{rel: 'hd'}]-(n2)-[:rel{rel:
          'obcomp'}]->()-[:rel]->(x:nw)
          where (x.cat is not null and x.cat in
          ['inf','ti','ssub','oti','ppart','smain','sv1','cp'])
          or (x.pt is not null and x.pt = 'ww')
          return distinct w.sentid, w.id, n2.id, x.id
        ]]></item>
        <item id="spod-ccdanvs-tel" lbl="telling"><![CDATA[
          match (w:word{pt: 'adj', graad: 'comp'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'obcomp'}]->()-[:rel]->(x:nw)
          where (x.cat is not null and x.cat in
          ['inf','ti','ssub','oti','ppart','smain','sv1','cp'])
          or (x.pt is not null and x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccdanpp" lbl="met als hoofd comparatief adjectief, gevolgd door PP">
        <item id="spod-ccdanpp-zin" lbl="zinnen"><![CDATA[
          match (w:word{pt: 'adj',graad: 'comp'})<-[:rel{rel: 'hd'}]-(:node)-[:rel{rel:
          'obcomp'}]->(:node)-[:rel{rel: 'body'}]->(n2:node{cat: 'pp'})
          return w.sentid, w.id, n2.id
        ]]></item>
        <item id="spod-ccdanpp-tel" lbl="telling"><![CDATA[
          match (w:word{pt: 'adj',graad: 'comp'})<-[:rel{rel: 'hd'}]-(:node)-[:rel{rel:
          'obcomp'}]->(:node)-[:rel{rel: 'body'}]->(:node{cat: 'pp'})
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccdanav" lbl="met als hoofd comparatief adjectief, gevolgd door A of ADV">
        <item id="spod-ccdanav-zin" lbl="zinnen"><![CDATA[
          match (w:word{pt: 'adj', graad: 'comp'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where (x.cat is not null and x.cat in ['advp','ap'])
          or (x.pt is not null and x.pt in ['adj','bw'])
          return w.sentid, w.id, x.id
        ]]></item>
        <item id="spod-ccdanav-tel" lbl="telling"><![CDATA[
          match (w:word{pt: 'adj', graad: 'comp'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'obcomp'}]->()-[:rel{rel: 'body'}]->(x:nw)
          where (x.cat is not null and x.cat in ['advp','ap'])
          or (x.pt is not null and x.pt in ['adj','bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccmm" lbl="met als hoofd &#34;meer&#34;, &#34;minder&#34;">
        <item id="spod-ccmm-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          where w.lemma in ['veel','minder','weinig']
          return w.sentid, w.id, n2.id
        ]]></item>
        <item id="spod-ccmm-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          where w.lemma in ['veel','minder','weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccmdnp" lbl="met als hoofd &#34;meer&#34;, &#34;minder&#34;, gevolgd door NP">
        <item id="spod-ccmdnp-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw{_np: true})
          where w.lemma in ['veel', 'minder', 'weinig']
          return w.sentid, w.id, x.id
        ]]></item>
        <item id="spod-ccmdnp-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(:nw{_np: true})
          where w.lemma in ['veel', 'minder', 'weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccmdvs" lbl="met als hoofd &#34;meer&#34;, &#34;minder&#34;, gevolgd door VP of S">
        <item id="spod-ccmdvs-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
          and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          return w.sentid, w.id, x.id
        ]]></item>
        <item id="spod-ccmdvs-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
          and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccmdpp" lbl="met als hoofd &#34;meer&#34;, &#34;minder&#34;, gevolgd door PP">
        <item id="spod-ccmdpp-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(n2:node{cat: 'pp'})
          where w.lemma in ['veel', 'minder', 'weinig']
          return distinct w.sentid, w.id, n2.id
        ]]></item>
        <item id="spod-ccmdpp-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(:node{cat: 'pp'})
          where w.lemma in ['veel', 'minder', 'weinig']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccmdav" lbl="met als hoofd &#34;meer&#34;, &#34;minder&#34;, gevolgd door A of ADV">
        <item id="spod-ccmdav-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
          and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          return distinct w.sentid, w.id, x.id
        ]]></item>
        <item id="spod-ccmdav-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw)
          where w.lemma in ['veel', 'minder', 'weinig']
          and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccnn" lbl="met als hoofd &#34;niet&#34;, &#34;niets&#34;, &#34;ander&#34;, &#34;anders&#34;">
        <item id="spod-ccnn-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->(n2)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        ]]></item>
        <item id="spod-ccnn-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccndnp" lbl="met als hoofd &#34;niet&#34;, &#34;niets&#34;, &#34;ander&#34;, &#34;anders&#34;, gevolgd door NP">
        <item id="spod-ccndnp-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(n2:nw{_np: true})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        ]]></item>
        <item id="spod-ccndnp-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(:nw{_np: true})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccndvs" lbl="met als hoofd &#34;niet&#34;, &#34;niets&#34;, &#34;ander&#34;, &#34;anders&#34;, gevolgd door VP of S">
        <item id="spod-ccndvs-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          return distinct w.sentid, w.id, x.id
        ]]></item>
        <item id="spod-ccndvs-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          and (x.cat in ['inf','ti','ssub','oti','ppart','smain','sv1','cp'] or x.pt = 'ww')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccndpp" lbl="met als hoofd &#34;niet&#34;, &#34;niets&#34;, &#34;ander&#34;, &#34;anders&#34;, gevolgd door PP">
        <item id="spod-ccndpp-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(n2:node{cat: 'pp'})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          return w.sentid, w.id, n2.id
        ]]></item>
        <item id="spod-ccndpp-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(:node{cat: 'pp'})
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ccndav" lbl="met als hoofd &#34;niet&#34;, &#34;niets&#34;, &#34;ander&#34;, &#34;anders&#34;, gevolgd door A of ADV">
        <item id="spod-ccndav-zin" lbl="zinnen"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          return w.sentid, w.id, x.id
        ]]></item>
        <item id="spod-ccndav-tel" lbl="telling"><![CDATA[
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'obcomp'}]->()-[:rel{rel:
          'body'}]->(x:nw)
          where w.lemma in ['niet', 'niets', 'ander', 'anders']
          and (x.cat in ['advp', 'ap'] or x.pt in ['adj', 'bw'])
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-neven" lbl="Nevenschikkingen">
      <item id="spod-neven-info" lbl="Info" class="info"><![CDATA[
        Bij nevenschikkingen maken we onderscheid naar gelang
        het aantal coordinatoren. Geen (1), één (2), twee (3) of meer (4).

        | | |
        | ---: | -- |
        | (1) | Zij wilden inspraak , medezeggenschap , democratisering |
        | | &nbsp; |
        | (2a) | Appels en peren |
        | b) | Appels of peren |
        | c) | De afzijdige maar invloedrijke waarnemer |
        | d) | Ze helpen eiwitten, vetten, etc. afbreken |
        | | &nbsp; |
        | (3) | Noch appels noch peren |
        | | &nbsp; |
        | (4) | U kunt gezond zijn, of ziek of arm of rijk |

        Indien er precies één coordinator is, maken we onderscheid tussen
        *en* (2a), *of* (2b), *maar* (2c) en het speciale geval waar de
        conjunctie wordt afgesloten met een woord zoals *enzovoorts* dat
        in de annotatie ook als coordinator wordt weergegeven (2d).

        We maken ook een onderverdeling naar gelang het aantal conjuncten
        dat in de coordinatie optreedt. Eén (5), twee (2), drie (6), vier,
        vijf, zes, of meer.

        | | |
        | ---: | -- |
        | (5) | de milieuverontreiniging, enzovoorts |
        | | &nbsp; |
        | (6) | cacaoboter , cacaopoeder of palmolie |

        Ten slotte wordt een onderscheid gemaakt naar de categorie van de
        conjuncten: NP (2), PP (7), hoofdzinnen (8), VP (9) en bijzinnen (10).

        | | |
        | ---: | -- |
        | (7) | in Arnhem en in België |
        | | &nbsp; |
        | (8) | Drie keer hadden ze dat beloofd en drie keer was die belofte weer ingetrokken |
        | | &nbsp; |
        | (9) | die sinds 1981 in Duitsland woont en werkt |
        | | &nbsp; |
        | (10) | (Hij zei) dat het er bij hoorde, en dat ik niet bang hoefde te zijn |
      ]]></item>
      <item id="spod-conj" lbl="alle nevenschikkingen">
        <item id="spod-conj-zin" lbl="zinnen"><![CDATA[
          match p = (:node{cat: 'conj'})
          return p
        ]]></item>
        <item id="spod-conj-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})
          return count(distinct(n.sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crdcount" lbl="nevenschikkingen met aantal coördinatoren (minimaal 1)"><![CDATA[
        select crd, count(*) as aantal
        from (
        match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
        with n, count(*) as crd
        return crd
        ) as foo
        group by crd
        order by crd
      ]]></item>
      <item id="spod-crd0" lbl="nevenschikkingen zonder coördinator">
        <item id="spod-crd0-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})
          optional match (n)-[r:rel{rel: 'crd'}]->()
          with n, r
          where r is null
          return n.sentid, n.id
        ]]></item>
        <item id="spod-crd0-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})
          optional match (n)-[r:rel{rel: 'crd'}]->()
          with n, r
          where r is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crd1" lbl="nevenschikkingen met 1 coördinator">
        <item id="spod-crd1-zin" lbl="zinnen"><![CDATA[
          match p = (:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with p, count(*) as cnt
          where cnt = 1
          return p
        ]]></item>
        <item id="spod-crd1-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt = 1
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crd1en" lbl="nevenschikkingen met 1 coördinator, en dat is &#34;en&#34;">
        <item id="spod-crd1en-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'en'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        ]]></item>
        <item id="spod-crd1en-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'en'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crd1of" lbl="nevenschikkingen met 1 coördinator, en dat is &#34;of&#34;">
        <item id="spod-crd1of-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'of'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        ]]></item>
        <item id="spod-crd1of-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'of'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crd1maa" lbl="nevenschikkingen met 1 coördinator, en dat is &#34;maar&#34;">
        <item id="spod-crd1maa-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'maar'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          return n.sentid, n.id, w.id
        ]]></item>
        <item id="spod-crd1maa-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(w:word{lemma: 'maar'})
          with n, w, count(*) as cnt
          where cnt = 1 and w is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crd1enz" lbl="nevenschikkingen met 1 coördinator, en de coordinator sluit de nevenschikking af (&#34;enzovoorts&#34;)">
        <item id="spod-crd1enz-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(x:nw)
          with n, x, count(*) as cnt
          where cnt = 1 and x.end = n.end
          return n.sentid, n.id, x.id
        ]]></item>
        <item id="spod-crd1enz-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          optional match (n)-[:rel{rel: 'crd'}]->(x:nw)
          with n, x, count(*) as cnt
          where cnt = 1 and x.end = n.end
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crd2" lbl="nevenschikkingen met 2 coördinatoren">
        <item id="spod-crd2-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt = 2
          return n.sentid, n.id
        ]]></item>
        <item id="spod-crd2-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt = 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crd2p" lbl="nevenschikkingen met meer dan 2 coördinatoren">
        <item id="spod-crd2p-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt > 2
          return n.sentid, n.id
        ]]></item>
        <item id="spod-crd2p-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->()
          with n, count(*) as cnt
          where cnt > 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-crd22" lbl="reeksvormers (nevenschikkingen van de vorm crd,cnj,crd,cnj...)">
        <item id="spod-crd22-zin" lbl="zinnen"><![CDATA[
          -- Dit werkt niet optimaal. Sommige reeksen worden niet gevonden.

          match (n1:nw)<-[:rel{rel:'crd'}]-(n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->(n3:nw)
          match (n2:nw{sentid: n.sentid})<-[:rel{rel:'cnj'}]-(n)-[:rel{rel: 'cnj'}]->(n4:nw)
          where n1.id = n.id + 1
          and (
          n1.id < n2.id
          and n2.id < n3.id
          and n3.id < n4.id
          or
          n1.begin < n2.begin
          and n2.begin < n3.begin
          and n3.begin < n4.begin
          )
          return n
        ]]></item>
        <item id="spod-crd22-tel" lbl="telling"><![CDATA[
          -- Dit werkt niet optimaal. Sommige reeksen worden niet gevonden.

          match (n1:nw)<-[:rel{rel:'crd'}]-(n:node{cat: 'conj'})-[:rel{rel: 'crd'}]->(n3:nw)
          match (n2:nw{sentid: n.sentid})<-[:rel{rel:'cnj'}]-(n)-[:rel{rel: 'cnj'}]->(n4:nw)
          where n1.id = n.id + 1
          and (
          n1.id < n2.id
          and n2.id < n3.id
          and n3.id < n4.id
          or
          n1.begin < n2.begin
          and n2.begin < n3.begin
          and n3.begin < n4.begin
          )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cnjcount" lbl="nevenschikkingen met aantal conjuncten (minimaal 1)"><![CDATA[
        select cnj, count(*) as aantal
        from (
        match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
        with n, count(*) as cnj
        return cnj
        ) as foo
        group by cnj
        order by cnj
      ]]></item>
      <item id="spod-cnj1" lbl="nevenschikkingen met slechts 1 conjunct">
        <item id="spod-cnj1-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 1
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnj1-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 1
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cnj2" lbl="nevenschikkingen met 2 conjuncten">
        <item id="spod-cnj2-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 2
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnj2-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 2
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cnj3" lbl="nevenschikkingen met 3 conjuncten">
        <item id="spod-cnj3-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 3
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnj3-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 3
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cnj4" lbl="nevenschikkingen met 4 conjuncten">
        <item id="spod-cnj4-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 4
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnj4-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 4
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cnj5" lbl="nevenschikkingen met 5 conjuncten">
        <item id="spod-cnj5-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 5
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnj5-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 5
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cnj6" lbl="nevenschikkingen met 6 conjuncten">
        <item id="spod-cnj6-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 6
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnj6-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt = 6
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cnj6p" lbl="nevenschikkingen met meer dan 6 conjuncten">
        <item id="spod-cnj6p-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt > 6
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnj6p-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'conj'})-[:rel{rel: 'cnj'}]->()
          with n, count(*) as cnt
          where cnt > 6
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-cnjnp" lbl="nevenschikking van NP&#39;s">
        <item id="spod-cnjnp-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{_np: true})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2._np is null
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnjnp-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{_np: true})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2._np is null
          return n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-cnjpp" lbl="nevenschikking van PP&#39;s">
        <item id="spod-cnjpp-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'pp'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'pp'
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnjpp-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'pp'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'pp'
          return n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-cnjmain" lbl="nevenschikking van hoofdzinnen">
        <item id="spod-cnjmain-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'smain'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'smain'
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnjmain-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'smain'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'smain'
          return n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-cnjvp" lbl="nevenschikking van VP">
        <item id="spod-cnjvp-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n1:nw)
          where n1.cat in ['ssub','ti','ppart','inf']
          or n1.pt = 'ww'
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where not ( n2.cat is not null and n2.cat in ['ssub','ti','ppart','inf']
          or n2.pt is not null and n2.pt = 'ww' )
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnjvp-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n1:nw)
          where n1.cat in ['ssub','ti','ppart','inf']
          or n1.pt = 'ww'
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where not ( n2.cat is not null and n2.cat in ['ssub','ti','ppart','inf']
          or n2.pt is not null and n2.pt = 'ww' )
          return n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-cnjcp" lbl="nevenschikking van bijzinnen">
        <item id="spod-cnjcp-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'cp'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'cp'
          return n.sentid, n.id
        ]]></item>
        <item id="spod-cnjcp-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (:nw{cat: 'cp'})
          return n.sentid, n.id
          except
          match (n:node{cat: 'conj'}) -[:rel{rel: 'cnj'}]-> (n2:nw)
          where n2.cat is null or n2.cat != 'cp'
          return n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
    </item>
    <item id="spod-wgroep" lbl="Woordgroepen">
      <item id="spod-wgroep-info" lbl="Info" class="info"><![CDATA[
        Voor woordgroepen onderscheiden we hier naamwoordgroepen (1),
        voorzetselgroepen (2), bijvoeglijk-naamwoordgroepen (3) en
        bijwoordgroepen (4).

        | | |
        | ---: | -- |
        | (1) | een grote boom |
        | | &nbsp; |
        | (2) | op een tak |
        | | &nbsp; |
        | (3) | heel erg geliefd |
        | | &nbsp; |
        | (4) | spelenderwijs |
      ]]></item>
      <item id="spod-np" lbl="np">
        <item id="spod-np-zin" lbl="zinnen"><![CDATA[
          match (x:nw{_np: true})
          return x.sentid, x.id
        ]]></item>
        <item id="spod-np-tel" lbl="telling"><![CDATA[
          match (x:nw{_np: true})
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-pp" lbl="pp">
        <item id="spod-pp-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'pp'})
          return n.sentid, n.id
        ]]></item>
        <item id="spod-pp-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'pp'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ap" lbl="ap">
        <item id="spod-ap-zin" lbl="zinnen"><![CDATA[
          match (x:nw)<-[r:rel]-()
          where (x.cat is not null and x.cat = 'ap')
          or (x.pt is not null and x.pt = 'adj')
          and r.rel != 'hd'
          return x.sentid, x.id
        ]]></item>
        <item id="spod-ap-tel" lbl="telling"><![CDATA[
          match (x:nw)<-[r:rel]-()
          where (x.cat is not null and x.cat = 'ap')
          or (x.pt is not null and x.pt = 'adj')
          and r.rel != 'hd'
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-advp" lbl="advp">
        <item id="spod-advp-zin" lbl="zinnen"><![CDATA[
          match (x:nw)<-[r:rel]-()
          where (x.cat is not null and x.cat = 'advp')
          or (x.pt is not null and x.pt = 'bw')
          and r.rel != 'hd'
          return x.sentid, x.id
        ]]></item>
        <item id="spod-advp-tel" lbl="telling"><![CDATA[
          match (x:nw)<-[r:rel]-()
          where (x.cat is not null and x.cat = 'advp')
          or (x.pt is not null and x.pt = 'bw')
          and r.rel != 'hd'
          with distinct x.sentid as sentid, x.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-ppgroep" lbl="Voorzetselgroepen">
      <item id="spod-ppgroep-info" lbl="Info" class="info"><![CDATA[
        Voorzetselgroepen worden onderscheiden naar grammaticale
        functie en naar interne structuur. Voorzetselgroepen kunnen
        optreden als bepaling bij nomina (1), adjectieven (2) of
        bij werkwoorden (6). Dit laatste geval wordt in de traditionele
        grammatica een bijwoordelijke bepaling genoemd. Voorzetselgroepen
        kunnen ook als complement optreden. Hier onderscheiden we
        voorzetselvoorwerpen (3), locatief/directinele complementen (4)
        en predicatieve complementen (5).

        | | |
        | ---: | -- |
        | (1) | De vrouw van de buurman |
        | | &nbsp; |
        | (2a) | De door hem beschreven voorvallen |
        | b) | De op zichzelf rationele beslissingen |
        | | &nbsp; |
        | (3) | We rekenen op zijn steun |
        | | &nbsp; |
        | (4a) | De ketchup vindt u bij de groenteafdeling |
        | b) | We rijden wel even naar het station |
        | | &nbsp; |
        | (5a) | Die aanpak is niet zonder risico |
        | b) | Je moet in het bezit zijn van een visum |
        | c) | De haven is van cruciale betekenis |
        | | &nbsp; |
        | (6) | We gaan vissen bij de brug |

        Voorzetselgroepen worden onderverdeeld aan de hand van hun
        interne structuur. We onderscheiden de meest gangbare structuur
        waarbij een voorzetsel direct gevolgd wordt door een NP (7) en
        de structuur waarbij een R-pronomen direct of indirect gevolgd
        wordt door het bijbehorende voorzetsel (8). Ten slotte volgt
        een aparte telling voor het aantal voorzetseluitdrukkingen.
        Dit zijn versteende combinaties zoals *ten tijde van*,
        *door middel van*, *naar aanleiding van* die zich als
        voorzetsel gedragen.

        | | |
        | ---: | -- |
        | (7) | in de kooi |
        | | &nbsp; |
        | (8) | Hij houdt daar helemaal niet van |
      ]]></item>
      <item id="spod-ppnp" lbl="grammaticale functie, bepalingen bij zelfstandige naamwoorden">
        <item id="spod-ppnp-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'mod'}]-(:node{cat: 'np'})
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ppnp-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'mod'}]-(:node{cat: 'np'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ppap" lbl="grammaticale functie, bepalingen bij adjectieven (en als adjectief gebruikte deelwoorden)">
        <item id="spod-ppap-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'mod'}]-(n2:node{cat:'ap'})
          return n.sentid, n.id
          union
          match (n:node{cat: 'pp'})<-[:rel{rel: 'mod'}]-(n2:node)
          where n2.cat in ['ppart','ppres']
          and not exists((n2)<-[:rel{rel: 'vc'}]-())
          and not exists((n2)<-[:rel{rel: 'cnj'}]-()<-[:rel{rel: 'vc'}]-())
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ppap-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:node{cat: 'pp'})<-[:rel{rel: 'mod'}]-(n2:node{cat:'ap'})
          return distinct n.sentid, n.id
          union
          match (n:node{cat: 'pp'})<-[:rel{rel: 'mod'}]-(n2:node)
          where n2.cat in ['ppart','ppres']
          and not exists((n2)<-[:rel{rel: 'vc'}]-())
          and not exists((n2)<-[:rel{rel: 'cnj'}]-()<-[:rel{rel: 'vc'}]-())
          return distinct n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-pppc" lbl="grammaticale functie, voorzetselvoorwerp">
        <item id="spod-pppc-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'pc'}]-()
          return n.sentid, n.id
        ]]></item>
        <item id="spod-pppc-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'pc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ppld" lbl="grammaticale functie, locatief/directioneel complement">
        <item id="spod-ppld-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'ld'}]-()
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ppld-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'ld'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-pppredc" lbl="grammaticale functie, predicatief complement">
        <item id="spod-pppredc-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'predc'}]-()
          return n.sentid, n.id
        ]]></item>
        <item id="spod-pppredc-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'predc'}]-()
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ppbep" lbl="grammaticale functie, bijwoordelijke bepaling">
        <item id="spod-ppbep-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'mod'}]-(n1)<-[r:rel]-(n2)
          where n1.cat in ['smain','sv1','whq','ssub','inf']
          or (
          n1.cat = 'ppart'
          and (
          r.rel = 'vc'
          or (
          r.rel = 'cnj'
          and exists((n2)<-[:rel{rel: 'vc'}]-())
          )
          )
          )
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ppbep-tel" lbl="telling"><![CDATA[
          match (n:node{cat: 'pp'})<-[:rel{rel: 'mod'}]-(n1)<-[r:rel]-(n2)
          where n1.cat in ['smain','sv1','whq','ssub','inf']
          or (
          n1.cat = 'ppart'
          and (
          r.rel = 'vc'
          or (
          r.rel = 'cnj'
          and exists((n2)<-[:rel{rel: 'vc'}]-())
          )
          )
          )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ppinp" lbl="interne structuur, P + NP">
        <item id="spod-ppinp-zin" lbl="zinnen"><![CDATA[
          match (n1)<-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(n2)
          where n1.begin = n.begin and n2.end = n.end
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ppinp-tel" lbl="telling"><![CDATA[
          match (n1)<-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(n2)
          where n1.begin = n.begin and n2.end = n.end
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ppirp" lbl="interne structuur, +R-pronomen + P">
        <item id="spod-ppirp-zin" lbl="zinnen"><![CDATA[
          match (n1)<-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(w:word{pt:
          'vnw'})
          where w.begin = n.begin and n1.end = n.end
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ppirp-tel" lbl="telling"><![CDATA[
          match (n1)<-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})-[:rel{rel: 'obj1'}]->(w:word{pt:
          'vnw'})
          where w.begin = n.begin and n1.end = n.end
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ppimwu" lbl="interne structuur, complex voorzetsel">
        <item id="spod-ppimwu-zin" lbl="zinnen"><![CDATA[
          match (:node{cat: 'mwu'})<-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ppimwu-tel" lbl="telling"><![CDATA[
          match (:node{cat: 'mwu'})<-[:rel{rel: 'hd'}]-(n:node{cat: 'pp'})
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-aj" lbl="Adjectiefgroepen">
      <item id="spod-aj-info" lbl="Info" class="info"><![CDATA[
        Adjectiefgroepen worden onderscheiden naar grammaticale functie en naar
        interne structuur. Adjectiefgroepen kunnen optreden als bepaling bij nomina (1), (2),
        traditioneel "bijvoegelijke bepaling" genoemd, en bij werkwoorden of andere bijvoeglijke
        naamwoorden (3), (4), traditioneel bijwoordelijke bepaling genoemd. Adjectiefgroepen kunnen
        ook optreden met als relatie "predm", en dat zijn gevallen die traditionaal bekend staan als
        bepaling van gesteldheid (5) (6). Ten slotte kan een adjectiefgroep optreden als predicatief
        complement (naamwoordelijk deel van het gezegde), zoals in (7), (8).

        | | |
        | ---: | -- |
        | (1) | De *aardige* buurman |
        | (2) | De *nogal vervelende* vergadering |
        | | &nbsp; |
        | (3) | Hij trapte de bal *hard* over het doel |
        | (4) | De dienst is *volledig* kosteloos |
        | | &nbsp; |
        | (5) | Hij kwam *ziek* binnen |
        | (6) | Hij liet het knipsel *dol van trots* aan iedereen zien |
        | | &nbsp; |
        | (7) | Ik vind dat *idioot* |
        | (8) | De dienst is *volledig kosteloos* |
        | | &nbsp; |
        | (9) | Het boek is *beschikbaar via de uitgever* |
        | | &nbsp; |
        | (10) | Het boek werd *tien jaar later* gepubliceerd |
        | (11) | De *mij onbekende* schrijver bleek een natuurtalent |
        | | &nbsp; |
        | (12) | De schat is *afkomstig uit Japan* |
        | (13) | Ron is *bang dat dit iets te maken heeft met Sirius Zwarts* |

        Adjectiefgroepen kunnen ook onderverdeel worden aan de hand van hun interne structuur.
        We onderscheiden adjectieven die hun eentje optreden (1), (3), (4), (5), (7); adjectieven
        die voorkomen
        met een bepaling ter linkerzijde (2), (8); adjectieven die voorkomen met een bepaling rechts
        van
        het adjectief (9); adjectieven die voorkomen met een complement, links van het adjectief
        (10), (11) en
        ten slotte de gevallen waarbij het adjectief optreedt met een complement ter rechterzijde
        (12), (13).
      ]]></item>
      <item id="spod-ajbepn" lbl="grammaticale functie, bijvoegelijke bepaling (bepaling bij zelfstandig naamwoord)">
        <item id="spod-ajbepn-zin" lbl="zinnen"><![CDATA[
          match (n)<-[:rel*0..1{rel: 'cnj'}]-()<-[:rel{rel: 'mod'}]-({cat: 'np'})
          where n.cat = 'ap' or n.pt = 'adj'
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajbepn-tel" lbl="telling"><![CDATA[
          match (n)<-[:rel*0..1{rel: 'cnj'}]-()<-[:rel{rel: 'mod'}]-({cat: 'np'})
          where n.cat = 'ap' or n.pt = 'adj'
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ajbepva" lbl="grammaticale functie, bijwoordelijke bepaling (bepaling bij werkwoord, adjectief, ...)">
        <item id="spod-ajbepva-zin" lbl="zinnen"><![CDATA[
          match (n)<-[:rel*0..1{rel: 'cnj'}]-()<-[:rel{rel: 'mod'}]-(n2:node)
          where n2.cat != 'np' and (n.cat = 'ap' or n.pt = 'adj')
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajbepva-tel" lbl="telling"><![CDATA[
          match (n)<-[:rel*0..1{rel: 'cnj'}]-()<-[:rel{rel: 'mod'}]-(n2:node)
          where n2.cat != 'np' and (n.cat = 'ap' or n.pt = 'adj')
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ajpredm" lbl="grammaticale functie, bepaling van gesteldheid etc.">
        <item id="spod-ajpredm-zin" lbl="zinnen"><![CDATA[
          match (n)<-[:rel*0..1{rel: 'cnj'}]-()<-[:rel{rel: 'predm'}]-()
          where n.cat = 'ap' or n.pt = 'adj'
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajpredm-tel" lbl="telling"><![CDATA[
          match (n)<-[:rel*0..1{rel: 'cnj'}]-()<-[:rel{rel: 'predm'}]-()
          where n.cat = 'ap' or n.pt = 'adj'
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ajpredc" lbl="grammaticale functie, predicatief complement">
        <item id="spod-ajpredc-zin" lbl="zinnen"><![CDATA[
          match (n)<-[:rel*0..1{rel: 'cnj'}]-()<-[:rel{rel: 'predc'}]-()
          where n.cat = 'ap' or n.pt = 'adj'
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajpredc-tel" lbl="telling"><![CDATA[
          match (n)<-[:rel*0..1{rel: 'cnj'}]-()<-[:rel{rel: 'predc'}]-()
          where n.cat = 'ap' or n.pt = 'adj'
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ajaj" lbl="interne structuur, ADJ">
        <item id="spod-ajaj-zin" lbl="zinnen"><![CDATA[
          match (n:word{pt: 'adj'})<-[r:rel]-()
          where r.rel != 'hd'
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajaj-tel" lbl="telling"><![CDATA[
          match (n:word{pt: 'adj'})<-[r:rel]-()
          where r.rel != 'hd'
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ajmodaj" lbl="interne structuur, MOD ADJ">
        <item id="spod-ajmodaj-zin" lbl="zinnen"><![CDATA[
          match (n1)<-[:rel{rel: 'mod'}]-(n{cat: 'ap'})-[:rel{rel: 'hd'}]->(n2)
          where n1.begin < n2.begin
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajmodaj-tel" lbl="telling"><![CDATA[
          match (n1)<-[:rel{rel: 'mod'}]-(n{cat: 'ap'})-[:rel{rel: 'hd'}]->(n2)
          where n1.begin < n2.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ajcaj" lbl="interne structuur|, COMPL ADJ">
        <item id="spod-ajcaj-zin" lbl="zinnen"><![CDATA[
          match (n1)<-[r:rel]-(n{cat: 'ap'})-[:rel{rel: 'hd'}]->(n2)
          optional match (n1)-[:rel*0]->(n1v{_vorfeld: true})
          with n, n1, n2, n1v, r
          where any(x in ['predc','obj1','obj2','pc','me','vc'] where x = r.rel)
          and n1v is null
          and n1.begin < n2.begin
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajcaj-tel" lbl="telling"><![CDATA[
          match (n1)<-[r:rel]-(n{cat: 'ap'})-[:rel{rel: 'hd'}]->(n2)
          optional match (n1)-[:rel*0]->(n1v{_vorfeld: true})
          with n, n1, n2, n1v, r
          where any(x in ['predc','obj1','obj2','pc','me','vc'] where x = r.rel)
          and n1v is null
          and n1.begin < n2.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ajajmod" lbl="interne structuur, ADJ MOD">
        <item id="spod-ajajmod-zin" lbl="zinnen"><![CDATA[
          match (n1)<-[:rel{rel: 'mod'}]-(n{cat: 'ap'})-[:rel{rel: 'hd'}]->(n2)
          where n1.begin > n2.begin
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajajmod-tel" lbl="telling"><![CDATA[
          match (n1)<-[:rel{rel: 'mod'}]-(n{cat: 'ap'})-[:rel{rel: 'hd'}]->(n2)
          where n1.begin > n2.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ajajc" lbl="interne structuur, ADJ COMPL">
        <item id="spod-ajajc-zin" lbl="zinnen"><![CDATA[
          match (n1)<-[r:rel]-(n{cat: 'ap'})-[:rel{rel: 'hd'}]->(n2)
          optional match (n1)-[:rel*0]->(n1v{_nachfeld: true})
          with n, n1, n2, n1v, r
          where any(x in ['predc','obj1','obj2','pc','me','vc'] where x = r.rel)
          and n1v is null
          and n1.begin > n2.begin
          return n.sentid, n.id
        ]]></item>
        <item id="spod-ajajc-tel" lbl="telling"><![CDATA[
          match (n1)<-[r:rel]-(n{cat: 'ap'})-[:rel{rel: 'hd'}]->(n2)
          optional match (n1)-[:rel*0]->(n1v{_nachfeld: true})
          with n, n1, n2, n1v, r
          where any(x in ['predc','obj1','obj2','pc','me','vc'] where x = r.rel)
          and n1v is null
          and n1.begin > n2.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-ww" lbl="Werkwoorden">
      <item id="spod-ww-info" lbl="Info" class="info"><![CDATA[
        Onder het kopje werkwoorden worden de vaste werkwoordelijke uitdrukkingen geteld (1).

        | | |
        | ---: | -- |
        | (1a) | aan bod komen |
        | b) | ter kennis geven |
        | c) | op prijs stellen |

        Daarnaast maken we een onderscheid bij werkwoordclusters tussen de zogenaamde
        rode en groene volgorde. Bij de groene werkwoordvolgorde gaat het voltooid
        deelwoord in de werkwoordcluster aan het hulpwerkwoord vooraf (2), en bij
        de rode volgorde volgt het voltooid deelwoord het hulpwerkwoord (3).

        | | |
        | ---: | -- |
        | (2a) | zijn boek zal morgen gepresenteerd worden |
        | b) | ze zouden nooit een woord met elkaar gewisseld hebben |
        | | &nbsp; |
        | (3a) | zijn boek zal morgen worden gepresenteerd |
        | b) | ze zouden nooit een woord met elkaar hebben gewisseld |

        Voorbeelden van werkwoordclusters worden gegeven in (2), (3), en (4).

        | | |
        | ---: | -- |
        | (4a) | Moet op korte termijn worden opgetreden? |
        | b) | De zaak moet aanhangig worden gemaakt |
        | c) | Ze zeiden dat ik dat zou hebben moeten kunnen zien aankomen |

        De "accusativus cum infinitivo" constructie vertoont de beroemde
        'cross-serial' afhankelijkheden. Voorbeelden zijn (5).
        Deze query werkt niet voor het CGN corpus.

        | | |
        | ---: | -- |
        | (5a) | Ik heb hem het boek zien lezen |
        | b) | Ik heb hem de olifanten helpen voeren |
        | c) | Ik heb hem de oppasser de olifanten zien helpen voeren |

        De passieve werkwoorden worden gebruikt in de lijdende vorm, als in (6).
        Het gaat hierbij om de gevallen waarbij een onderwerp aanwezig is.
        Deze query werkt niet voor het CGN corpus.

        | | |
        | ---: | -- |
        | (6a) | Hij wordt geslagen |
        | b) | Het monument zal spoedig te zien zijn in het Amsterdamse Oosterpark |

        De niet-persoonlijke passieven identificeert de gevallen van de lijdende vorm
        waarbij geen echt onderwerp beschikbaar is. In die gevallen wordt vaak *er*
        als plaatsonderwerp gebruikt.

        | | |
        | ---: | -- |
        | (7a) | Er werd niet meer over gesproken |
        | b) | In Amsterdam werd niet gedemonstreerd |
      ]]></item>
      <item id="spod-vwuit" lbl="vaste werkwoordelijke uitdrukkingen">
        <item id="spod-vwuit-zin" lbl="zinnen"><![CDATA[
          match (n:node)<-[:rel{rel: 'svp'}]-()
          where n.cat is not null
          return n.sentid, n.id
        ]]></item>
        <item id="spod-vwuit-tel" lbl="telling"><![CDATA[
          match (n:node)<-[:rel{rel: 'svp'}]-()
          where n.cat is not null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-groen" lbl="groene werkwoordsvolgorde">
        <item id="spod-groen-zin" lbl="zinnen"><![CDATA[
          match (w:word{wvorm: 'vd'})<-[:rel{rel: 'hd'}]-(:node)<-[:rel{rel:
          'vc'}]-(:node)-[:rel{rel: 'hd'}]->(x)
          where w.begin < x.begin
          and not exists( (w)<-[:rel*2]-(:node{sentid: w.sentid, cat: 'smain'}) )
          and not exists( (w)<-[:rel*2]-(:node{sentid: w.sentid, cat: 'sv1'}) )
          return w.sentid, w.id
        ]]></item>
        <item id="spod-groen-tel" lbl="telling"><![CDATA[
          match (w:word{wvorm: 'vd'})<-[:rel{rel: 'hd'}]-(:node)<-[:rel{rel:
          'vc'}]-(:node)-[:rel{rel: 'hd'}]->(x)
          where w.begin < x.begin
          and not exists( (w)<-[:rel*2]-(:node{sentid: w.sentid, cat: 'smain'}) )
          and not exists( (w)<-[:rel*2]-(:node{sentid: w.sentid, cat: 'sv1'}) )
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-rood" lbl="rode werkwoordsvolgorde">
        <item id="spod-rood-zin" lbl="zinnen"><![CDATA[
          match (n:word{wvorm: 'vd'})<-[:rel{rel: 'hd'}]-()<-[:rel]-()-[:rel{rel:
          'hd'}]->(w:word{pt: 'ww'})
          optional match (n)<-[:rel]-()<-[:rel]-(n2:node{cat: 'smain'})
          optional match (n)<-[:rel]-()<-[:rel]-(n3:node{cat: 'sv1'})
          with n, n2, n3, w
          where n.begin > w.begin
          and n2 is null
          and n3 is null
          return n.sentid, n.id
        ]]></item>
        <item id="spod-rood-tel" lbl="telling"><![CDATA[
          match (n:word{wvorm: 'vd'})<-[:rel{rel: 'hd'}]-()<-[:rel]-()-[:rel{rel:
          'hd'}]->(w:word{pt: 'ww'})
          optional match (n)<-[:rel]-()<-[:rel]-(n2:node{cat: 'smain'})
          optional match (n)<-[:rel]-()<-[:rel]-(n3:node{cat: 'sv1'})
          with n, n2, n3, w
          where n.begin > w.begin
          and n2 is null
          and n3 is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-wwclus" lbl="werkwoordsclusters">
        <item id="spod-wwclus-zin" lbl="zinnen"><![CDATA[
          match (n1:nw)<-[:rel]-(n:node)<-[:rel{rel: 'vc'}]-(n0:node)-[:rel{rel:
          'hd'}]->(n2:word{pt: 'ww'})
          where n.cat in ['ti','inf','ppart']
          and not(n0.cat in ['smain','sv1']) -- dit hoeft niet per se n0 te zijn???
          and n1.begin < n2.begin
          return n.sentid, n.id
        ]]></item>
        <item id="spod-wwclus-tel" lbl="telling"><![CDATA[
          match (n1:nw)<-[:rel]-(n:node)<-[:rel{rel: 'vc'}]-(n0:node)-[:rel{rel:
          'hd'}]->(n2:word{pt: 'ww'})
          where n.cat in ['ti','inf','ppart']
          and not(n0.cat in ['smain','sv1']) -- dit hoeft niet per se n0 te zijn???
          and n1.begin < n2.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-accinf" lbl="accusativus cum infinitivo">
        <item id="spod-accinf-zin" lbl="zinnen"><![CDATA[
          -- niet voor Corpus Gesproken Nederlands

          match (x)<-[:rel]-(n:node{cat: 'inf'})<-[:rel{rel: 'vc'}]-(n1)-[:rel{rel:
          'hd'}]->(w:word{pt: 'ww'})
          match (n)-[:rel{rel: 'su'}]->()<-[:rel{rel: 'obj1'}]-(n1)
          where not n1.cat in ['smain','sv1']
          and x.begin < w.begin
          return n.sentid, n.id
        ]]></item>
        <item id="spod-accinf-tel" lbl="telling"><![CDATA[
          -- niet voor Corpus Gesproken Nederlands

          match (x)<-[:rel]-(n:node{cat: 'inf'})<-[:rel{rel: 'vc'}]-(n1)-[:rel{rel:
          'hd'}]->(w:word{pt: 'ww'})
          match (n)-[:rel{rel: 'su'}]->()<-[:rel{rel: 'obj1'}]-(n1)
          where not n1.cat in ['smain','sv1']
          and x.begin < w.begin
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-passive" lbl="passief">
        <item id="spod-passive-zin" lbl="zinnen"><![CDATA[
          -- niet voor Corpus Gesproken Nederlands

          match (n1:nw)<-[:rel{rel: 'obj1'}]-()<-[r:rel*0..1]-(n:node)<-[:rel{rel:
          'vc'}]-()<-[:rel]-(n0)
          match (n0)-[:rel{rel: 'su'}]->(n1)
          where (length(r) = 0 and n.cat = 'ppart' or length(r) = 1 and n.cat = 'ti')
          return n.sentid, n.id
        ]]></item>
        <item id="spod-passive-tel" lbl="telling"><![CDATA[
          -- niet voor Corpus Gesproken Nederlands

          match (n1:nw)<-[:rel{rel: 'obj1'}]-()<-[r:rel*0..1]-(n:node)<-[:rel{rel:
          'vc'}]-()<-[:rel]-(n0)
          match (n0)-[:rel{rel: 'su'}]->(n1)
          where (length(r) = 0 and n.cat = 'ppart' or length(r) = 1 and n.cat = 'ti')
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-nppas" lbl="niet-persoonlijke passief">
        <item id="spod-nppas-zin" lbl="zinnen"><![CDATA[
          -- niet voor Corpus Gesproken Nederlands

          match (n:nw)<-[:rel{rel: 'vc'}]-()
          match (n)<-[:rel]-()-[:rel{rel: 'hd'}]->(n1)
          match (n)<-[:rel]-(n2)
          optional match (pn:node{cat: 'sv1'})-[:rel]->(n)
          optional match (pn)-[:rel{rel: 'su'}]->(px1)
          optional match (pn)-[:rel{rel: 'hd'}]->(px2)
          with n, n1, n2, pn, px1, px2
          where (n1.sc in ['passive','te_passive']
          or (n1.pt = 'ww'
          and (
          ( n.cat = 'ppart'
          and not exists ((n)-[:rel{rel: 'obj1'}]->())
          and not exists ((n)-[:rel{rel: 'su'}]->())
          and not exists ((n)-[:rel{rel: 'vc'}]->())
          and not exists ((n)-[:rel{rel: 'predc'}]->()) )
          or ( n.cat = 'ti'
          and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'obj1'}]->())
          and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'su'}]->())
          and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'vc'}]->())
          and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'predc'}]->()) )
          ))
          ) and (
          -- n2 is een parent van n
          not exists((n2)-[:rel{rel: 'su'}]->())
          and (
          n2.cat in ['smain','ssub']
          or (
          n2.cat = 'sv1'
          and not (
          -- imperatief
          pn is not null
          and px1 is null
          and not (px2.stype is not null and not px2.stype = 'imparative')
          and not ((px2.tense is not null and px2.tense = 'past') or
          (px2.pvagr is not null and px2.pvagr in ['mv','met-t']) or
          (px2.pvtijd is not null and px2.pvtijd = 'verl') or
          (px2.lemma is not null and px2.lemma in
          ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben'])
          )
          -- einde imperatief
          )))
          )
          return n.sentid, n.id
        ]]></item>
        <item id="spod-nppas-tel" lbl="telling"><![CDATA[
          -- niet voor Corpus Gesproken Nederlands

          match (n:nw)<-[:rel{rel: 'vc'}]-()
          match (n)<-[:rel]-()-[:rel{rel: 'hd'}]->(n1)
          match (n)<-[:rel]-(n2)
          optional match (pn:node{cat: 'sv1'})-[:rel]->(n)
          optional match (pn)-[:rel{rel: 'su'}]->(px1)
          optional match (pn)-[:rel{rel: 'hd'}]->(px2)
          with n, n1, n2, pn, px1, px2
          where (n1.sc in ['passive','te_passive']
          or (n1.pt = 'ww'
          and (
          ( n.cat = 'ppart'
          and not exists ((n)-[:rel{rel: 'obj1'}]->())
          and not exists ((n)-[:rel{rel: 'su'}]->())
          and not exists ((n)-[:rel{rel: 'vc'}]->())
          and not exists ((n)-[:rel{rel: 'predc'}]->()) )
          or ( n.cat = 'ti'
          and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'obj1'}]->())
          and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'su'}]->())
          and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'vc'}]->())
          and not exists ((n)-[:rel{rel: 'body'}]->()-[:rel{rel: 'predc'}]->()) )
          ))
          ) and (
          -- n2 is een parent van n
          not exists((n2)-[:rel{rel: 'su'}]->())
          and (
          n2.cat in ['smain','ssub']
          or (
          n2.cat = 'sv1'
          and not (
          -- imperatief
          pn is not null
          and px1 is null
          and not (px2.stype is not null and not px2.stype = 'imparative')
          and not ((px2.tense is not null and px2.tense = 'past') or
          (px2.pvagr is not null and px2.pvagr in ['mv','met-t']) or
          (px2.pvtijd is not null and px2.pvtijd = 'verl') or
          (px2.lemma is not null and px2.lemma in
          ['zijn','kunnen','willen','moeten','mogen','zullen','denken','geloven','vinden','hebben'])
          )
          -- einde imperatief
          )))
          )
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-wwsch" lbl="Scheidbare werkwoorden">
      <item id="spod-wwsch-info" lbl="Info" class="info"><![CDATA[
        De queries voor scheidbare werkwoorden zijn niet beschikbaar voor de handmatig geannoteerde
        corpora.

        Werkwoorden met een scheidbaar partikel worden gegeven in (1) en (2).

        | | |
        | ---: | -- |
        | (1a) | Ik heb hem opgebeld |
        | b) | Ik bel hem op |
        | c) | Ik heb hem op willen bellen |

        We maken daarbij een onderscheid tussen gevallen waarbij het partikel
        gescheiden is van het werkwoord (1bc) en gevallen waarbij het partikel
        in het werkwoord geincorporeerd is (1a).

        Daarnaast bekijken we de gevallen waarbij het werkwoord niet finiet is (1ac).
        En binnen die gevallen onderscheiden we opnieuw gevallen waarbij het partikel
        gescheiden is van het werkwoord (1c) en gevallen waarbij het partikel in het
        werkwoord geincorporeerd is (1a).
      ]]></item>
      <item id="spod-vpart" lbl="Werkwoorden met een scheidbaar partikel">
        <item id="spod-vpart-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          return w.sentid, w.id
        ]]></item>
        <item id="spod-vpart-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-vpartex" lbl="Werkwoorden met een scheidbaar partikel, partikel gescheiden van het werkwoord">
        <item id="spod-vpartex-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
          and w2.frame starts with 'particle'
          return w.sentid, w.id
        ]]></item>
        <item id="spod-vpartex-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
          and w2.frame starts with 'particle'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-vpartin" lbl="Werkwoorden met een scheidbaar partikel, partikel geïncorporeerd in het werkwoord">
        <item id="spod-vpartin-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          return w.sentid, w.id
          except
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
          and w2.frame starts with 'particle'
          return w.sentid, w.id
        ]]></item>
        <item id="spod-vpartin-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (w:word)
          where w.sc starts with 'part_'
          return distinct w.sentid, w.id
          except
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
          and w2.frame starts with 'particle'
          return distinct w.sentid, w.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-vprtn" lbl="Niet-finiete werkwoorden met een scheidbaar partikel">
        <item id="spod-vprtn-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          and (w.wvorm is null or w.wvorm != 'pv')
          return w.sentid, w.id
        ]]></item>
        <item id="spod-vprtn-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          and (w.wvorm is null or w.wvorm != 'pv')
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-vprtnex" lbl="Niet-finiete werkwoorden met een scheidbaar partikel, partikel gescheiden van het werkwoord">
        <item id="spod-vprtnex-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
          and (w.wvorm is null or w.wvorm != 'pv')
          and w2.frame starts with 'particle'
          return w.sentid, w.id
        ]]></item>
        <item id="spod-vprtnex-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
          and (w.wvorm is null or w.wvorm != 'pv')
          and w2.frame starts with 'particle'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-vprtnin" lbl="Niet-finiete werkwoorden met een scheidbaar partikel, partikel geïncorporeerd in het werkwoord">
        <item id="spod-vprtnin-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:word)
          where w.sc starts with 'part_'
          and (w.wvorm is null or w.wvorm != 'pv')
          return w.sentid, w.id
          except
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
          and (w.wvorm is null or w.wvorm != 'pv')
          and w2.frame starts with 'particle'
          return w.sentid, w.id
        ]]></item>
        <item id="spod-vprtnin-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (w:word)
          where w.sc starts with 'part_'
          and (w.wvorm is null or w.wvorm != 'pv')
          return distinct w.sentid, w.id
          except
          match (w:word)<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'svp'}]->(w2)
          where w.sc starts with 'part_'
          and (w.wvorm is null or w.wvorm != 'pv')
          and w2.frame starts with 'particle'
          return distinct w.sentid, w.id
          ) as foo
        ]]></item>
      </item>
    </item>
    <item id="spod-wwtijden" lbl="Werkwoordstijden ">
      <item id="spod-wwtijden-info" lbl="Info" class="info"><![CDATA[
        We onderscheiden de vier klassieke werkwoordstijden: onvoltooid
        tegenwoordige tijd (1), onvoltooid verleden tijd (2), voltooid
        tegenwoordige tijd (3) en voltooid verleden tijd (4).

        | | |
        | ---: | -- |
        | (1) | De bakker bakt het brood |
        | | &nbsp; |
        | (2) | De bakker bakte het brood |
        | | &nbsp; |
        | (3) | De bakker heeft het brood gebakken |
        | | &nbsp; |
        | (4) | De bakker had het brood gebakken |
      ]]></item>
      <item id="spod-ott" lbl="Onvoltooid tegenwoordige tijd">
        <item id="spod-ott-zin" lbl="zinnen"><![CDATA[
          match (w:word{pvtijd: 'tgw'})
          where w.lemma != 'hebben' and w.lemma != 'zijn' or not exists ((w)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'}))
          return w
        ]]></item>
        <item id="spod-ott-tel" lbl="telling"><![CDATA[
          match (w:word{pvtijd: 'tgw'})
          where w.lemma != 'hebben' and w.lemma != 'zijn' or not exists ((w)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'}))
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ovt" lbl="Onvoltooid verleden tijd">
        <item id="spod-ovt-zin" lbl="zinnen"><![CDATA[
          match (w:word{pvtijd: 'verl'})
          where w.lemma != 'hebben' and w.lemma != 'zijn' or not exists ((w)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'}))
          return w
        ]]></item>
        <item id="spod-ovt-tel" lbl="telling"><![CDATA[
          match (w:word{pvtijd: 'verl'})
          where w.lemma != 'hebben' and w.lemma != 'zijn' or not exists ((w)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'}))
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-vtt" lbl="Voltooid tegenwoordige tijd">
        <item id="spod-vtt-zin" lbl="zinnen"><![CDATA[
          match (w:word{pvtijd: 'tgw'})<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'vc'}]->(n:node{cat:
          'ppart'})
          optional match (n)-[:rel{rel:'hd'}]->(w2)
          with w, w2
          where w.lemma = 'hebben' or w.lemma = 'zijn'
          return w, w2
        ]]></item>
        <item id="spod-vtt-tel" lbl="telling"><![CDATA[
          match (w:word{pvtijd: 'tgw'})<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'vc'}]->(n:node{cat:
          'ppart'})
          where w.lemma = 'hebben' or w.lemma = 'zijn'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-vvt" lbl="Voltooid verleden tijd">
        <item id="spod-vvt-zin" lbl="zinnen"><![CDATA[
          match (w:word{pvtijd: 'verl'})<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'vc'}]->(n:node{cat:
          'ppart'})
          optional match (n)-[:rel{rel:'hd'}]->(w2)
          with w, w2
          where w.lemma = 'hebben' or w.lemma = 'zijn'
          return w, w2
        ]]></item>
        <item id="spod-vvt-tel" lbl="telling"><![CDATA[
          match (w:word{pvtijd: 'verl'})<-[:rel{rel: 'hd'}]-()-[:rel{rel: 'vc'}]->(n:node{cat:
          'ppart'})
          where w.lemma = 'hebben' or w.lemma = 'zijn'
          with distinct w.sentid as sentid, w.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-wwvolgorde" lbl="Volgorde van werkwoordstijden">
      <item id="spod-wwvolgorde-info" lbl="Info" class="info"><![CDATA[
        Deze queries onderscheiden finiete zinnen die zelf een finiet
        zinscomplement bevatten. Hierbij kijken we naar de combinaties van de
        (onvoltooide) werkwoordstijd van de persoonsvorm in de dominerende zin
        en de (onvoltooide) werkwoordstijd van de persoonsvorm in de zin die
        als complement optreedt. De combinaties zijn dan tegenwoordige tijd
        met tegenwoordige tijd (1), tegenwoordige tijd met verleden tijd (2),
        verleden tijd met tegenwoordige tijd (3) en verleden tijd met verleden
        tijd (4).

        | | |
        | ---: | -- |
        | (1) | De minister verklaart dat de economie blijft groeien |
        | | &nbsp; |
        | (2) | De minister verklaart dat hij het dossier in de trein liet liggen |
        | | &nbsp; |
        | (3) | De minister verklaarde dat de economie blijft groeien |
        | | &nbsp; |
        | (4) | De minister verklaarde dat hij het dossier in de trein liet liggen |
      ]]></item>
      <item id="spod-ottott" lbl="ott, ott: &#34;hij zegt dat hij komt&#34;">
        <item id="spod-ottott-zin" lbl="zinnen"><![CDATA[
          match (w1:word{pvtijd: 'tgw'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'vc'}]->()-[:rel{rel: 'body'}]->()-[:rel{rel: 'hd'}]->(w2:word{pvtijd: 'tgw'})
          where (w1.lemma != 'hebben' and w1.lemma != 'zijn' or not exists ((w1)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          and (w2.lemma != 'hebben' and w2.lemma != 'zijn' or not exists ((w2)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          return w1, w2
        ]]></item>
        <item id="spod-ottott-tel" lbl="telling"><![CDATA[
          match (w1:word{pvtijd: 'tgw'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'vc'}]->()-[:rel{rel: 'body'}]->()-[:rel{rel: 'hd'}]->(w2:word{pvtijd: 'tgw'})
          where (w1.lemma != 'hebben' and w1.lemma != 'zijn' or not exists ((w1)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          and (w2.lemma != 'hebben' and w2.lemma != 'zijn' or not exists ((w2)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          with distinct w1.sentid as sentid, w1.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ottovt" lbl="ott, ovt: &#34;hij zegt dat hij kwam&#34;">
        <item id="spod-ottovt-zin" lbl="zinnen"><![CDATA[
          match (w1:word{pvtijd: 'tgw'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'vc'}]->()-[:rel{rel: 'body'}]->()-[:rel{rel: 'hd'}]->(w2:word{pvtijd: 'verl'})
          where (w1.lemma != 'hebben' and w1.lemma != 'zijn' or not exists ((w1)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          and (w2.lemma != 'hebben' and w2.lemma != 'zijn' or not exists ((w2)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          return w1, w2
        ]]></item>
        <item id="spod-ottovt-tel" lbl="telling"><![CDATA[
          match (w1:word{pvtijd: 'tgw'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'vc'}]->()-[:rel{rel: 'body'}]->()-[:rel{rel: 'hd'}]->(w2:word{pvtijd: 'verl'})
          where (w1.lemma != 'hebben' and w1.lemma != 'zijn' or not exists ((w1)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          and (w2.lemma != 'hebben' and w2.lemma != 'zijn' or not exists ((w2)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          with distinct w1.sentid as sentid, w1.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ovtott" lbl="ovt, ott: &#34;hij zei dat hij komt&#34;">
        <item id="spod-ovtott-zin" lbl="zinnen"><![CDATA[
          match (w1:word{pvtijd: 'verl'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'vc'}]->()-[:rel{rel: 'body'}]->()-[:rel{rel: 'hd'}]->(w2:word{pvtijd: 'tgw'})
          where (w1.lemma != 'hebben' and w1.lemma != 'zijn' or not exists ((w1)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          and (w2.lemma != 'hebben' and w2.lemma != 'zijn' or not exists ((w2)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          return w1, w2
        ]]></item>
        <item id="spod-ovtott-tel" lbl="telling"><![CDATA[
          match (w1:word{pvtijd: 'verl'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'vc'}]->()-[:rel{rel: 'body'}]->()-[:rel{rel: 'hd'}]->(w2:word{pvtijd: 'tgw'})
          where (w1.lemma != 'hebben' and w1.lemma != 'zijn' or not exists ((w1)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          and (w2.lemma != 'hebben' and w2.lemma != 'zijn' or not exists ((w2)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          with distinct w1.sentid as sentid, w1.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-ovtovt" lbl="ovt, ovt: &#34;hij zei dat hij kwam&#34;">
        <item id="spod-ovtovt-zin" lbl="zinnen"><![CDATA[
          match (w1:word{pvtijd: 'verl'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'vc'}]->()-[:rel{rel: 'body'}]->()-[:rel{rel: 'hd'}]->(w2:word{pvtijd: 'verl'})
          where (w1.lemma != 'hebben' and w1.lemma != 'zijn' or not exists ((w1)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          and (w2.lemma != 'hebben' and w2.lemma != 'zijn' or not exists ((w2)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          return w1, w2
        ]]></item>
        <item id="spod-ovtovt-tel" lbl="telling"><![CDATA[
          match (w1:word{pvtijd: 'verl'})<-[:rel{rel: 'hd'}]-()-[:rel{rel:
          'vc'}]->()-[:rel{rel: 'body'}]->()-[:rel{rel: 'hd'}]->(w2:word{pvtijd: 'verl'})
          where (w1.lemma != 'hebben' and w1.lemma != 'zijn' or not exists ((w1)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          and (w2.lemma != 'hebben' and w2.lemma != 'zijn' or not exists ((w2)<-[:rel{rel:
          'hd'}]-()-[:rel{rel: 'vc'}]->(:node{cat: 'ppart'})))
          with distinct w1.sentid as sentid, w1.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-inb" lbl="Inbedding in finiete zinnen">
      <item id="spod-inb-info" lbl="Info" class="info"><![CDATA[
        Bij deze queries wordt gekeken naar de complexiteit van de zinnen in termen
        van de inbedding van finiete bijzinnen. Een hoofdzin zonder finiete bijzin
        geldt dan als "geen inbedding". Een hoofdzin met een finiete bijzin geldt als
        "minstens 1 finiete zinsinbedding. Indien de finiete bijzin zelf ook een finiete
        bijzin bevat is er sprake van minstens 2 finiete zinsinbeddingen. En zo verder.
      ]]></item>
      <item id="spod-inb-all" lbl="telling van alle niveaus"><![CDATA[
        match (n:node{_clause: true})
        optional match (n)-[:rel*1..]->(n2:node{sentid:n.sentid, _clause: true})
        with n, n2
        where n2 is null
        return n._clause_lvl - 1 as niveau, count(*) as aantal
        order by niveau
      ]]></item>
      <item id="spod-inb0" lbl="finiete zinnen zonder inbedding"><![CDATA[
        match (n:node{_clause_lvl: 1})
        optional match (n)-[:rel*1..]->(n2:node{sentid:n.sentid, _clause: true})
        with n, n2
        where n2 is null
        return n
      ]]></item>
      <item id="spod-inb1" lbl="minstens 1 finiete zinsinbedding"><![CDATA[
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 1
        return p
      ]]></item>
      <item id="spod-inb2" lbl="minstens 2 finiete zinsinbeddingen"><![CDATA[
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 2
        return p
      ]]></item>
      <item id="spod-inb3" lbl="minstens 3 finiete zinsinbeddingen"><![CDATA[
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 3
        return p
      ]]></item>
      <item id="spod-inb4" lbl="minstens 4 finiete zinsinbeddingen"><![CDATA[
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 4
        return p
      ]]></item>
      <item id="spod-inb5" lbl="minstens 5 finiete zinsinbeddingen"><![CDATA[
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 5
        return p
      ]]></item>
      <item id="spod-inb6" lbl="minstens 6 finiete zinsinbeddingen"><![CDATA[
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 6
        return p
      ]]></item>
      <item id="spod-inb7" lbl="minstens 7 finiete zinsinbeddingen"><![CDATA[
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 7
        return p
      ]]></item>
      <item id="spod-inb8" lbl="minstens 8 finiete zinsinbeddingen"><![CDATA[
        match p = (n:node{_clause:true})-[:rel*1..]->(n2:node{sentid:n.sentid, _clause:true})
        where n2._clause_lvl - n._clause_lvl = 8
        return p
      ]]></item>
    </item>
    <item id="sod-topiextr" lbl="Topicalisatie en Extractie">
      <item id="spod-topiextr-info" lbl="Info" class="info"><![CDATA[
        De eerste query, "np-topic is subject", bekijkt hoe vaak in een
        hoofdzin die met een NP begint, deze NP als subject van de persoonsvorm
        fungeert (1), terwijl de tweede query die gevallen telt waarbij zo'n NP
        een andere rol bekleedt (2). De derde query, "topic is niet lokaal",
        identificeert de gevallen waarbij de eerste constituent van de hoofdzin
        geen rol speelt in die hoofdzin, maar een rol speelt in een ingebedde
        constituent. Bij de vierde en vijfde query wordt onderzocht hoe vaak
        in een wh-vraag of relatieve bijzin het wh-element, dan wel de woordgroep
        die het relatieve voornaamwoord bevat een rol speelt in de hoofdzin
        (lokaal, 4) dan wel in een ingebedde bijzin (niet lokaal, 5).

        | | |
        | ---: | -- |
        | (1) | De kinderen geloven nog in Sinterklaas |
        | | &nbsp; |
        | (2) | Sinterklaas keurden ze geen blik waardig |
        | | &nbsp; |
        | (3) | Wie denk je dat ik tegenkwam? |
        | | &nbsp; |
        | (4) | Welke procedure moet worden gevolgd? |
        | | &nbsp; |
        | (5) | Ze keek alleen naar wat ze dacht dat het Amerikaanse belang was |
      ]]></item>
      <item id="spod-nptsub" lbl="np-topic is subject">
        <item id="spod-nptsub-zin" lbl="zinnen"><![CDATA[
          match (n:nw{_vorfeld: true, _np: true})<-[r:rel]-()
          where r.rel in ['su','sup'] and r.id is null
          return n.sentid, n.id
        ]]></item>
        <item id="spod-nptsub-tel" lbl="telling"><![CDATA[
          match (n:nw{_vorfeld: true, _np: true})<-[r:rel]-()
          where r.rel in ['su','sup'] and r.id is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
      <item id="spod-nptnsub" lbl="np-topic is geen subject">
        <item id="spod-nptnsub-zin" lbl="zinnen"><![CDATA[
          match (n:nw{_vorfeld: true, _np: true})<-[r:rel]-()
          where r.id is null
          return n.sentid, n.id
          except
          match (n:nw{_vorfeld: true, _np: true})<-[r:rel]-()
          where r.id is null and r.rel in ['su','sup']
          return n.sentid, n.id
        ]]></item>
        <item id="spod-nptnsub-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:nw{_vorfeld: true, _np: true})<-[r:rel]-()
          where r.id is null
          return distinct n.sentid, n.id
          except
          match (n:nw{_vorfeld: true, _np: true})<-[r:rel]-()
          where r.id is null and r.rel in ['su','sup']
          return distinct n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-tnonloc" lbl="topic is niet lokaal">
        <item id="spod-tnonloc-zin" lbl="zinnen"><![CDATA[
          match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
          where r.id is null
          return n.sentid, n.id
          except
          match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
          match (n)-[:rel*1..]->(n0:node{sentid: n.sentid})-[r2:rel]->()-[:rel*0..]->(:nw{sentid:
          n.sentid, _vorfeld: true})
          where r.id is null and r2.id is null and n0.cat in ['ssub','smain']
          return n.sentid, n.id
        ]]></item>
        <item id="spod-tnonloc-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
          where r.id is null
          return distinct n.sentid, n.id
          except
          match (n:node{cat: 'ssub'})-[r:rel]->()-[:rel*0..]->(:nw{_vorfeld: true})
          match (n)-[:rel*1..]->(n0:node{sentid: n.sentid})-[r2:rel]->()-[:rel*0..]->(:nw{sentid:
          n.sentid, _vorfeld: true})
          where r.id is null and r2.id is null and n0.cat in ['ssub','smain']
          return distinct n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-locext" lbl="lokale extractie">
        <item id="spod-locext-zin" lbl="zinnen"><![CDATA[
          match (n:nw)<-[r:rel]-()
          where r.rel in ['whd','rhd']
          return n.sentid, n.id
          except
          match (n:nw)<-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid:
          n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)<-[:rel]-()<-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
          and n2 is null
          return n.sentid, n.id
        ]]></item>
        <item id="spod-locext-tel" lbl="telling"><![CDATA[
          select count(distinct(sentid)) as zinnen, count(*) as items
          from (
          match (n:nw)<-[r:rel]-()
          where r.rel in ['whd','rhd']
          return distinct n.sentid, n.id
          except
          match (n:nw)<-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid:
          n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)<-[:rel]-()<-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
          and n2 is null
          return distinct n.sentid, n.id
          ) as foo
        ]]></item>
      </item>
      <item id="spod-nlocext" lbl="niet-lokale extractie">
        <item id="spod-nlocext-zin" lbl="zinnen"><![CDATA[
          match (n:nw)<-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid:
          n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)<-[:rel]-()<-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
          and n2 is null
          return n.sentid, n.id
        ]]></item>
        <item id="spod-nlocext-tel" lbl="telling"><![CDATA[
          match (n:nw)<-[r:rel]-(nn)
          match (nn)-[:rel*1..]->(:node{sentid:n.sentid, cat:'ssub'})-[:rel*1..]->(n0:node{sentid:
          n.sentid, cat: 'ssub'})-[:rel*1..]->(n)
          optional match (n0)<-[:rel]-()<-[:rel{rel: 'obcomp'}]-(n2)
          with r, n, n0, n2
          where r.rel in ['whd','rhd']
          and n2 is null
          with distinct n.sentid as sentid, n.id as id
          return count(distinct(sentid)) as zinnen, count(*) as items
        ]]></item>
      </item>
    </item>
    <item id="spod-parser" lbl="Parser succes">
      <item id="spod-parser-info" lbl="Info" class="info"><![CDATA[
        Dit deel werkt niet voor handmatig geannoteerde corpora.

        De query telt hoevaak de parser een volledige analyse van
        de zin heeft kunnen uitvoeren (dus zonder woorden over te
        slaan of fragmenten te combineren).
      ]]></item>
      <item id="spod-ok" lbl="volledige parse">
        <item id="spod-ok-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1, skips:0})
          return s
        ]]></item>
        <item id="spod-ok-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1, skips:0})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-catcount" lbl="aantal geparste delen"><![CDATA[
        -- alleen voor automatisch verwerkte corpora

        match (s:sentence)
        where s.cats is not null
        return s.cats as delen, count(*) as zinnen
        order by delen
      ]]></item>
      <item id="spod-cats0" lbl="geen enkel deel is geparst">
        <item id="spod-cats0-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:0})
          return s
        ]]></item>
        <item id="spod-cats0-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:0})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-cats1" lbl="parse bestaat uit één deel">
        <item id="spod-cats1-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1})
          return s
        ]]></item>
        <item id="spod-cats1-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:1})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-cats2" lbl="parse bestaat uit twee losse delen">
        <item id="spod-cats2-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:2})
          return s
        ]]></item>
        <item id="spod-cats2-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:2})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-cats3" lbl="parse bestaat uit drie losse delen">
        <item id="spod-cats3-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:3})
          return s
        ]]></item>
        <item id="spod-cats3-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{cats:3})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-cats4" lbl="parse bestaat uit vier of meer losse delen">
        <item id="spod-cats4-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.cats > 3
          return s
        ]]></item>
        <item id="spod-cats4-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.cats > 3
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-skipcount" lbl="aantal overgeslagen woorden"><![CDATA[
        -- alleen voor automatisch verwerkte corpora

        match (s:sentence)
        where s.skips is not null
        return s.skips as "overgeslagen woorden", count(*) as zinnen
        order by "overgeslagen woorden"
      ]]></item>
      <item id="spod-skips0" lbl="geen enkel woord is overgeslagen">
        <item id="spod-skips0-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:0})
          return s
        ]]></item>
        <item id="spod-skips0-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:0})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-skips1" lbl="een van de woorden is overgeslagen">
        <item id="spod-skips1-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:1})
          return s
        ]]></item>
        <item id="spod-skips1-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:1})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-skips2" lbl="twee van de woorden zijn overgeslagen">
        <item id="spod-skips2-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:2})
          return s
        ]]></item>
        <item id="spod-skips2-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:2})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-skips3" lbl="drie van de woorden zijn overgeslagen">
        <item id="spod-skips3-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:3})
          return s
        ]]></item>
        <item id="spod-skips3-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence{skips:3})
          return count(*) as zinnen
        ]]></item>
      </item>
      <item id="spod-skips4" lbl="vier of meer van de woorden zijn overgeslagen">
        <item id="spod-skips4-zin" lbl="zinnen"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.skips > 3
          return s
        ]]></item>
        <item id="spod-skips4-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (s:sentence)
          where s.skips > 3
          return count(*) as zinnen
        ]]></item>
      </item>
    </item>
    <item id="spod-onbekend" lbl="Onbekende woorden">
      <item id="spod-onbekend-info" lbl="Info" class="info"><![CDATA[
        Dit deel werkt niet voor handmatig geannoteerde corpora.

        De parser kent een heel scale aan heuristieken om voor woorden die niet
        in het woordenboek staan toch een woordsoort toe te kennen. In deze
        afdeling wordt onderzocht hoe vaak zulke onbekende woorden voorkwamen,
        en op welke manier onbekende woorden alsnog werden behandeld. Eerst wordt
        het totaal aantal woorden gegeven, gevolgd door het aantal woorden dat in
        het woordenboek stond. De derde query geeft het aantal onbekende woorden terug.
        De drie volgende queries geven vervolgens aan hoevaak een onbekend woord als
        samenstelling werd gezien, of als naam (maar niet uit de namenlijst) of op
        een nog andere manier werden behandeld.
      ]]></item>
      <item id="spod-his" lbl="&#34;alle&#34; woorden (nodes met attribuut @his)">
        <item id="spod-his-zin" lbl="woorden"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
          return w

          except

          match (w:nw)-[:rel]->(w2:nw)
          where w.his is not null
          and w2.his is not null
          return w
        ]]></item>
        <item id="spod-his-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          select count(*) as woorden
          from (
          match (w:nw)
          where w.his is not null
          return w

          except

          match (w:nw)-[:rel]->(w2:nw)
          where w.his is not null
          and w2.his is not null
          return w
          ) as foo
        ]]></item>
      </item>
      <item id="spod-normal" lbl="woorden uit het woordenboek of de namenlijst">
        <item id="spod-normal-zin" lbl="woorden"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'normal'})
          return w

          except

          match (w:nw{his: 'normal'})-[:rel]->(w2:nw)
          where w2.his is not null
          return w
        ]]></item>
        <item id="spod-normal-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora
          select count(*) as woorden
          from (
          match (w:nw{his: 'normal'})
          return w

          except

          match (w:nw{his: 'normal'})-[:rel]->(w2:nw)
          where w2.his is not null
          return w
          ) as foo
        ]]></item>
      </item>
      <item id="spod-onbeken" lbl="woorden niet direct uit het woordenboek">
        <item id="spod-onbeken-zin" lbl="woorden"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
          and not (w.his in ['normal','robust_skip','skip'])
          return w

          except

          match (w:nw)-[:rel]->(w2:nw)
          where w.his is not null
          and w2.his is not null
          return w
        ]]></item>
        <item id="spod-onbeken-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          select count(*) as woorden
          from (
          match (w:nw)
          where w.his is not null
          and not (w.his in ['normal','robust_skip','skip'])
          return w

          except

          match (w:nw)-[:rel]->(w2:nw)
          where w.his is not null
          and w2.his is not null
          return w
          ) as foo
        ]]></item>
      </item>
      <item id="spod-compoun" lbl="woorden herkend als samenstelling">
        <item id="spod-compoun-zin" lbl="woorden"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'compound'})
          return w

          except

          match (w:nw{his: 'compound'})-[:rel]->(w2:nw)
          where w2.his is not null
          return w
        ]]></item>
        <item id="spod-compoun-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          select count(*) as woorden
          from (
          match (w:nw{his: 'compound'})
          return w

          except

          match (w:nw{his: 'compound'})-[:rel]->(w2:nw)
          where w2.his is not null
          return w
          ) as foo
        ]]></item>
      </item>
      <item id="spod-name" lbl="woorden herkend als naam (maar niet uit namenlijst)">
        <item id="spod-name-zin" lbl="woorden"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:nw{his: 'name'})
          return w

          except

          match (w:nw{his: 'name'})-[:rel]->(w2:nw)
          where w2.his is not null
          return w
        ]]></item>
        <item id="spod-name-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          select count(*) as woorden
          from (
          match (w:nw{his: 'name'})
          return w

          except

          match (w:nw{his: 'name'})-[:rel]->(w2:nw)
          where w2.his is not null
          return w
          ) as foo
        ]]></item>
      </item>
      <item id="spod-noun" lbl="onbekende woorden die niet als samenstelling of naam werden herkend">
        <item id="spod-noun-zin" lbl="woorden"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          match (w:nw)
          where w.his is not null
          and not (w.his in ['normal','compound','name','robust_skip','skip'])
          return w

          except

          match (w:nw)-[:rel]->(w2:nw)
          where w.his is not null
          and w2.his is not null
          return w
        ]]></item>
        <item id="spod-noun-tel" lbl="telling"><![CDATA[
          -- alleen voor automatisch verwerkte corpora

          select count(*) as woorden
          from (
          match (w:nw)
          where w.his is not null
          and not (w.his in ['normal','compound','name','robust_skip','skip'])
          return w

          except

          match (w:nw)-[:rel]->(w2:nw)
          where w.his is not null
          and w2.his is not null
          return w
          ) as foo
        ]]></item>
      </item>
    </item>
  </item>
</menu>
